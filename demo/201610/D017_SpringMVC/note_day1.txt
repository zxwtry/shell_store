SpringMVC的框架原理：
    前端控制器、处理器映射器、处理器适配器、视图解析器
SpringMVC入门程序：
    目的：对前端控制器、处理器映射器、处理器适配器、视图解析器学习
    非注解的处理器映射器、处理器适配器
    注解的处理器映射器、处理器适配器
SpringMVC和MyBatis整合
SpringMVC注解开发
    常用的注解学习
    参数绑定(简单类型，POJO，集合类型)
    自定义参数绑定
SpringMVC和Struts2区别

note01: 什么是SpringMVC
    SpringMVC是Spring框架的一个模块，SpringMVC和Spring无需通过中间整合层进行整合。
    SpringMVC是一个基于MVC的Web框架。

note02: 什么是MVC && MVC在B/S系统下的应用
    MVC是一个设计模式

    用户   (request请求)--->   C控制器  --(请求模型进行处理)
        <--response响应  struts2的filter  |
                          接受用户请求    |
                --------- 响应用户请求    |
                |                |        |
                |                |        |
                |                |        |
                |                |        |
                |                |------ M模型
                |         (处理结果返回) POJO
                |                        Action
                |                        Service
                |                        DAO
                |
            视图渲染
            将模型数据填充
            到request域
                | 
                | 
                | 
              V视图

    (b/s系统下，模型无法将数据填充到视图)
第1步：用户发出请求，请求传送到控制层
第2步：控制层把请求委托给模型层，模型层通过Service DAO等等得到结果
第3步：模型层将结果返回给控制层
第4步：控制层将结果填充到视图层，形成视图
第5步：控制层响应用户请求，将视图响应给用户。

note03: SpringMVC框架
   
          (url)                                        (url-->处理器)
用户    (request)-->     前端控制器     --请求查找->     处理器映射器
                      DispatcherServlet    Handler     HandlerMapping
    <---(respone)       接受用户请求
                        响应用户请求    <-返回一个--
                         |   |  |         执行链
                         |   |  |         Handler
                         |   |  |         Execution
                         |   |  |         Chain
                         |   |  |         (Handler-
                         |   |  |         Interceptor1)
                         |   |  |         (Handler-
                         |   |  |         Interceptor2)
                         |   |  |         (Handler)
                         |   |  |
  ------------------------   |  ----------
  |                          |           |  前端控制器
  |                          |           |  请求适配器
  |                          |           |  执行Handler
  |                          |           |
  |                          |           |  处理器适配器
  |                          |           |  给前端控制器
  | 渲染视图                 |           |  返回ModelAndView
  | 返回View                 |           |
  |                          | 视图解析  |
  |                          | 返回View  |
  |                          |           |
  |                   视图解析器         |
  |                  ViewResolver        |
View视图                                 |
html                                     |
freemarker                               |
excel                                    |
                                         |             Handler处理器
                                         |           平常叫controller
                                         |              |        ↑
                                         |              |        |
                                         |             返回      |
                                         |        ModelAndView  执行 
                                         |              |        |
                                         |              ↓        |
                                         |     　　　　处理器适配器 
                                         ------------  HandlerAdapter
                                                       去执行Handler 

第01步：发起请求到前端控制器(DispatherServlet)
第02步：前端控制器去处理器映射器(HandlerMapping)请求对应处理器
第03步：处理器映射器将处理器执行链(HandlerExecutionChain)返回给前端控制器
第04步：前端控制器找到处理器适配器(HandlerAdapter)，执行业务
第05步：处理器适配器将业务交给处理器(Handler)(controller)去执行
第06步：处理器将ModelAndView返回给处理器适配器
第07步：处理器适配器将ModelAndView返回给前端控制器
第08步：前端控制器将ModelAndView交给视图解析器(ViewResolver)
第09步：视图解析器将解析好的view返回给前端控制器
第10步：前端控制器将view交给视图(View)生成html(完成填充数据)
第11步：视图将html返回给前端控制器
第12步：前端控制器响应用户请求(将html返回给用户)

组件的作用：
1， 前端控制器(DispatcherServlet)
    作用：  a,  接收请求，响应请求；
            b,  相当于MVC中的C
            c,  SpringMVC的中心
            d,  降低组件之间的耦合
            e,  不需要程序员开发
2,  处理器映射器(HandlerMapping)
    作用:   a,  从前端控制器得到用户请求的信息(url)，返回处理器执行链
            b,  实现方式：配置文件、实现接口、注解
            c,  不需要程序员开发
3， 处理器适配器(HandlerAdapter)
    作用:   a,  从前端控制器接收执行信息，将执行信息交给处理器执行
            b,  这是适配器模式的应用
            c,  就是让处理器依照处理器适配器要求的规则去执行
            d,  不需要程序员开发
4,  处理器(Handler)
    作用:   a,  真正执行用户请求的地方
            b,  相当于MVC中的M
            c,  SpringMVC的执行模块，DAO Service...
            d,  需要程序员开发
5,  视图解析器(View Resolver)
    作用:   a,  根据逻辑视图名解析成物理视图名即具体的页面地址
            b,  根据ModelAndView信息生成View视图对象
            c,  SpingMVC提供View视图类型：jstlView、freemarkerView
                pdfView等等。
            d,  不需要程序员开发
6,  视图(View)
    作用:   a,  对View渲染将处理结果通过页面展示给用户
            b,  一般情况需要使用页面标签或者页面模版技术
            c,  需要程序员开发

note04: 建表语句：
create database springmvc_1012 default  charset=utf8;

CREATE TABLE `items` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) NOT NULL COMMENT '商品名称',
  `price` float(10,1) NOT NULL COMMENT '商品定价',
  `detail` text COMMENT '商品描述',
  `pic` varchar(64) DEFAULT NULL COMMENT '商品图片',
  `createtime` datetime NOT NULL COMMENT '生产日期',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(32) NOT NULL COMMENT '用户名称',
  `birthday` date DEFAULT NULL COMMENT '生日',
  `sex` char(1) DEFAULT NULL COMMENT '性别',
  `address` varchar(256) DEFAULT NULL COMMENT '地址',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;

CREATE TABLE `orders` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL COMMENT '下单用户id',
  `number` varchar(32) NOT NULL COMMENT '订单号',
  `createtime` datetime NOT NULL COMMENT '创建订单时间',
  `note` varchar(100) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`),
  KEY `FK_orders_1` (`user_id`),
  CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

CREATE TABLE `orderdetail` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `orders_id` int(11) NOT NULL COMMENT '订单id',
  `items_id` int(11) NOT NULL COMMENT '商品id',
  `items_num` int(11) DEFAULT NULL COMMENT '商品购买数量',
  PRIMARY KEY (`id`),
  KEY `FK_orderdetail_1` (`orders_id`),
  KEY `FK_orderdetail_2` (`items_id`),
  CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

第一步：建立users(用户表)和items(商品信息表)
            这两张表都没有外键，只是简单的表
第二步：建立orders(订单表)：
            外键users_id：指向users
第三步：建立orderdetail(订单明细表)
            外键orders_id：指向items
            外键items_id：指向orders
过程是：小明建了两张orders，
        第一张orders对应2张orderdetail，
            两张orderdetail分别对应11本笔记本和12支笔
        第二张orders对应三张orderdetail，
            三张orderdetail分别对应3斤桃子、5斤苹果和6瓶水
        items表中，必需包含笔记本，笔，桃子，苹果，水

note05: 项目准备工作
在创建Dynamic Web Project的过程中，如果希望项目和MyEclipse能够互导
    将default output folder设置成：WebRoot\WEB-INF\classes
    将COntent directory设置成：WebRoot
版本选择：
    java:       jdk7
    eclipse:    indigo
    springmvc:  spring3.2
    mysql:      mysql5.7
jar包：
    有非常多jar包，但是最重要的是spring-webmvc包
    如果单单是SpringMVC的话，只需要：
        commons-logging-1.1.1.jar
        jstl-1.2.jar
        spring-aop-3.2.0.RELEASE.jar
        spring-aspects-3.2.0.RELEASE.jar
        spring-beans-3.2.0.RELEASE.jar
        spring-context-3.2.0.RELEASE.jar
        spring-context-support-3.2.0.RELEASE.jar
        spring-core-3.2.0.RELEASE.jar
        spring-expression-3.2.0.RELEASE.jar
        spring-jdbc-3.2.0.RELEASE.jar
        spring-orm-3.2.0.RELEASE.jar
        spring-test-3.2.0.RELEASE.jar
        spring-tx-3.2.0.RELEASE.jar
        spring-web-3.2.0.RELEASE.jar
        spring-webmvc-3.2.0.RELEASE.jar

note06: 项目进展1---配置前端控制器 
    在web.xml中配置前端控制器。
    需要配置<servlet>和<servlet-mapping>
        <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- contextConfigLocation配置springmvc加载 配置文件
            处理器映射器、处理器适配器等等
            
            如果不配置contextConfigLocation的话，默认加载的是
            /WEB-INF/servlet名称-servlet.xml(springmvc-servlet.xml)
        -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>claddpath:springmvc.xml</param-value>
        </init-param>
      </servlet>
      <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <!-- 
            第一种：*.action，访问.action结尾由DispatcherServlet进行解析
            第二种：/，所有访问的地址都由DispatcherServlet进行解析
                   对于静态文件的解析需要配置不让DispatcherServlet进行解析
                  使用第二种能够实现RESTful风格的url
            第三种：/*，这样配置不对
                　当最终需要转发到一个html页面时候，仍然会由DispatcherServlet解析html
                   不能根据html页面找到handler，会报错
         -->
        <url-pattern>*.action</url-pattern>
      </servlet-mapping>


note07: 项目进展2---配置处理器适配器
    (在框架流程图中，处理器映射器在前面，但是处理器适配是最接近业务处理的)
    (所以，在实际中经常会选择先去配置处理器适配器)
    在classpath下的springmvc.xml中配置处理器映射
        <!-- 处理器适配器 -->
        <!-- 所有的处理器适配器都实现HandlerAdapter接口 -->
        <!-- HandlerAdapter接口中的supports(Object handler)方法 -->
        <!-- 处理器适配器对其的实现是：
            public boolean supports(Object handler) {
                return (handler instanceof Controller);
            }
            public interface Controller {
                ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;
            }
         -->
        <bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/>

    
note08: 项目进展3---编写Handler
    需要实现Controller接口
    (实现了Controller接口才能由上面配置的处理器适配器来执行)
        //返回ModelAndView
        ModelAndView modelAndView = new ModelAndView();
        
        //相当于request.setAttribute(attributeValue)
        //在html页面中可以通过itemsList取数据
        modelAndView.addObject("itemsList", itemsList);
        
        //指定视图
        modelAndView.setViewName("/WEB-INF/html/items/itemsList.jsp");
    就是需要处理业务逻辑，返回一个ModelAndView


note09: 项目进展4---视图编写
    为了方便，在这里使用
    <c:forEach items="${itemsList}" var="item">
    <tr>
        <td>${item.name}</td>
        <td>${tiem.price}</td>
        <td><fmt:formatDate value="${item.createtime}" parrtern="yyyy-MM-dd HH:mm:ss"/></td>
        <td>${item.detail}</td>
    </tr>
    </c:forEach>
    来进行itemsList显示

note10: 项目进展5---配置处理器映射器和Handler
    在项目进展3中已经将Handler写好了，肯定要将Handler配置到springmvc.xml中
    当然，根据架构流程，首先要配置的是处理器映射器，具体配置如下：
    <!-- 处理器映射器 
      将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)
-->
    <bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/>
    处理器映射器的bean是不需要自己编写的。
    
    接下来就是配置Handler，Handler是自己编写的，需要提供具体的访问url
    <!-- 配置Handler -->
    <bean name="/queryItems.action" class="edu.zxw.goods.controller.ItemsController1"/>

note11: 项目进展6---配置视图解析器
    需要配置解析html，这里是jsp的视图解析器
    <!-- 视图解析器 
       解析jsp视图，默认使用jstl标签，classpath下要有jstl的包
    -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"/>

note12: 项目进展7---到现在，可以进行调试了
    纪录一个非常无语的事情：
        写Java代码的时候，为了Eclipse不报错，我常常先写一个return null;
        在写这份代码的时候，写自己的Handler即Controller的时候，
        写到最后忘了改写成return modelAndView，写的还是return null;
    自己调试的时候，总是以为访问不到页面，乱折腾一大堆。。。诶。。。
    这个习惯得改。。。


