note01: 自定义环境之以一般账户的角色工作时
    Bash Shell的启动配置文件中曾提到Bash Shell的启动配置文件。
    这种机制为用户提供自定义工作环境的弹性。使用者可比较启动配置文件，
    安排方便工作的环境。
    可自定义的配置文件，如下表所示：
        文件名                  时机
        ~/.bash_profile         登录时
        ~/.bashrc               执行新shell时
        ~/.bash_logout          注销时
        (这里的~指的是家目录)
    大多数主机在开设账号后，会自动在用户家目录中建立.bash_profile和.bashrc两个文件。
    而.bash_logout一般默认没有，需由用户自己建立。
    自定义环境的主要目的是要让用户登录主机时，能拥有安全及易于执行命令的环境，项目包括：建立文件的权限、命令搜寻路径、环境变量、命令提示符、别名、喜好的比较器、显示文件使用的颜色等。
    一般在.bash_profile设定可以一体使用的命令、搜寻路径及环境变量，而把其他大部分的设定放在.bashrc。因此.bash_profile文件比较小，.bashrc则比较大。
    建议：自定义.bash_profile时，仍然依循上述惯例，让它越简单越好。
          这样不但好维护，而且不易出错。
    以下是.bash_profile的设定范例
            #设定umask
            umask 022
            #登录后，也执行一个.bashrc
            if [ -f ~/.bashrc ]; then
                . ~/.bashrc
            fi
            #设定自己专用的程序路径
            if [ -d ~/bin ]; then
                PATH=~/bin:$PATH
            fi
            #设定CVS环境
            export CVSROOT=":pserver:zxwtry@192.168.1.2:/home/zxwtry"
            #设定Java环境
            export JAVA_HOME=~/jdk/bin
            export PATH=$PATH:$JAVA_HOME
        行2，设定新建文件、目录的安全权限，分别是644及755(即用666和777各减去022)
    以下是.bashrc的设定范例：
            #判断若不是在互动模式，则不执行.bashrc
            [ -z "$PS1" ] && return
            #设定有颜色的提示
            PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
            #设定方便使用的程序别名
            alias ll='ls -alF'
            alias la='ls -A'
            alias l='ls -CF'
            #如果系统没有启用bash_completion，可在这里启用
            if [ -f /usr/share/bash-completion/bash_completion ]; then
                . /usr/share/bash-completion/bash_completion
            elif [ -f /etc/bash_completion ]; then
                . /etc/bash_completion
            fi
            #重复的命令、ls、bg、fg、exit、ps等指令，不存入历史日志文件中。
            export HISTIGNORE="&:ls:ls *:[bf]g:exit:ps *"
            #设定自己常用的目录，可用cd指令快速切换
            export CDPATH=.:~:~/docs:~/src:~/tmp:/mnt:/usr/src:/usr/lib:/usr/local
    以下是.bash_logout的设定范例
            #注销时，清空tmp目录中的所有内容
            rm -rf ~/tmp/*

note02: 自定义环境---以系统管理员的角色工作时
    系统管理员维护的环境配置文件，主要有3个：
        1,  /etc/profile
        2,  /etc/bash.bashrc
        3,  /etc/skel 目录下所有文件
    前两个文件的用途，在Bash Shell的启动配置文件中已经说明。
    /etc/profile和/etc/bash.bashrc的设定，会影响所有账号的使用环境，因此，要特别小心。
    在/etc/profile中，通常会做如下设定：umask, PATH, 多国语言环境, 提示符号, 别名等等。
    bash.bashrc的内容，大多如下：
        [ -f /etc/profile ] && . /etc/profile
        这表明，当执行交互式的Shell时会检查/etc/profile是否存在，若存在，就执行它。这样的做法，等于是让管理员只要维护一份全局的/etc/profile配置文件即可。
    除了这两个文件，/etc/skel这个目录也很重要。它的作用是，当管理员开设新账户时，账号管理程序会把/etc/skel中的所有文件复制一份放到家目录中，作为用户的环境文件。
    
note03: 数组
    bash数组，其元素的个数没有限制，数组的索引由0开始，但不一定要连续，(可以跳号)。
    索引号也可以用算术表达式表示，如1+2
    bash 3.x只支持一维数组(关系型数组在Bash4.0才支持) 
    用例：
			root@zxwtry:~# A[0]=1
			root@zxwtry:~# A[0]='c'
			root@zxwtry:~# A[0]="good"
			root@zxwtry:~# echo ${A[1]}
			
			root@zxwtry:~# echo ${A[0]}
			good
			root@zxwtry:~# A[3]=1
			root@zxwtry:~# echo ${B[@]}
			
			root@zxwtry:~# echo ${A[@]}
			good 1
			root@zxwtry:~# echo ${A[*]}
			good 1
			root@zxwtry:~# echo ${#A[*]}
			2
			root@zxwtry:~# echo ${#A[@]}
			2
    ${A[@]} --- 一次取出所有的元素：得到以空白隔开的东东
    ${A[*]} --- 一次取出所有的元素：得到一整个字符串
    ${#A[@]} 或者 ${#A[*]} --- 得到数组的元素
    ${#数组[索引]}  --- 如果数组元素是字符串，得到字符串的长度
    unset A --- 取消数组
    unset A[3]  --- 取消某一个元素，取消了第4个元素

note04: Here Document --- 用Here Document设定变量
    bash有一种特殊的程序区域，叫Here Document，也可以用来设定变量。
    Here Document的基本语法：
        命令 <<标记
        ......
        ......
        ......
        标记
    这样会吧命令和标记之间的内容，利用转向输入的方式交给命令去处理。
    标记可以是任何字符串。选用标记的原则：尽量选不常用的字符组合，
        避免该字符串出现在输入的内容中造成bash预判。
    范例如下：
        wc -l <<HERE
        line 1
        line 2
        line 3
        HERE
        (经由wc计算结果得到3行)
    Here Document也支持变量替换。在输入的内容中，如果有变量，bash在转向前会先替换变量值
        From="From: me@example.edu.cn"    
        To="To: you@example.edu.cn"
        Subject="Subject: hello world"
        Msg="吃饭睡觉"
        Em="20161101.txt"
        cat > $Em <<HERE
        $From
        $To
        $Subject
        
        $Msg
        HERE
    执行结果如下：
        root@zxwtry:S005_LinuxShell编程与服务器管理# chmod +x code011_Here_Document_变量替换.sh 
        root@zxwtry:S005_LinuxShell编程与服务器管理# ./code011_Here_Document_变量替换.sh 
        root@zxwtry:S005_LinuxShell编程与服务器管理# cat 20161101.txt 
        From: me@example.edu.cn
        To: you@example.edu.cn
        Subject: hello world
        
        吃饭睡觉
    Here Document的变量设定
        WOW="WOW, great!"
        var=$(cat <<HERE
        Line 1 is good
        They are tencent, alibaba and baidu.
        $WOW
        HERE)
        echo $var
    执行结果如下：
        root@zxwtry:S005_LinuxShell编程与服务器管理# ./code012_Here_Document_变量设定.sh 
        ./code012_Here_Document_变量设定.sh: line 12: warning: here-document at line 8 delimited by end-of-file (wanted `HERE')
        Line 1 is good They are tencent, alibaba and baidu. WOW, great!
    替换$WOW的变量值之后转向输出，交给cat显示出来，其结果放置在$()中进行替换变量，得到上述结果。
    在标记加上双引号也是可以的，例如上例写成$(cat <<"HERE")，表示这个Here Document拥有和双引号一样的特性，即支持变量替换的功能。

note05: Here Document   --- 控制Here Document的格式
    Here Document支持两种控制输出格式的做法：
    1,  关闭变量替换的功能
        有时候，希望按照原本的样子转向输出，不做任何变量替换。做法如下：
            cat <<'HERE'
            Line 1 is good
            They are tencent, alibaba, and baidu.
            $WOW
            HERE
        行1中，对标记HERE加上单引号，即可关闭变量替换。
        执行结果：
            Line 1 is good
            They are tencent, alibaba, and baidu.
            $WOW
        $WOW还是保持原样，不做变量替换。
    2,  去掉每行之前的TAB字符：
            cat <<-'HERE'
                Line 1 is good.
                They are tencent, alibaba, and baidu.
                $WOW
            HERE
        行2~4每行前面都有一个TAB字符。行1在标记前加上-，表示要抑制各行首TAB的作用，输出结果同前例。

note06: Here Document   --- 利用Here Document做多行批注
    用例：
        : <<DO-NOTTHING
        这是第一行批注
        这是第二行批注
        这是第三行批注
        这是第四行批注
        DO-NOTTHING
        :代表"什么都不做"的空命令。这个区域在script中，bash会忽略不执行，因此，达到批注的效果。

note07: Here Document   --- 利用Here Document，打包C(或其他程序语言)的原始码
    这是Cracker散步安全漏洞时，最喜欢的用法。举例如下：
    代码在：code013_Here_Document_打包C的原始码.sh    
			#!/bin/bash
			echo "正在产生 hello.c...."
			echo
			cat <<'EOF' > hello.c
			#include <stdio.h>
			int main(){
			    printf("hello world!\n");
			    return 0;
			}
			EOF
			echo "编译hello.c..."
			echo
			#编译hello.c，产生执行文件
			gcc -o hello hello.c
			#若编译成功，就执行
			if [ $? -eq 0 ]; then
			    echo "执行hello..."
			    echo
			    ./hello
			else
			    echo 'Compile ERROR: hello.c'
			fi
    执行结果如下：
			root@zxwtry:S005_LinuxShell编程与服务器管理# ./code013_Here_Document_打包C的原始码.sh 
			正在产生 hello.c....
			
			编译hello.c...
			
			执行hello...
			
			hello world!
    这个script利用Here Document，夹带了一个hello.c程序的原始码，执行本script时会产生hello.c，
        接着利用gcc编译hello.c，若编译无误，就执行程序文件hello
    这就是shell script携带攻击程序的原型。

note08: 高级变量
    高级变量，有3个主题：
        1,  变量扩展
        2,  命令替换
        3,  算术扩展
    ${变量名称}     ---     变量替换    ---     ${filename}
    $(命令)         ---     命令替换    ---     $(ls /)
    $((算术式))     ---     算术扩展    ---     $((9+9))

note09: 变量扩展：测试存在性及空值
    1,  基本型：${变量名称} 
	    "变量存在"的定义：   如果变量曾设值过，则称该变量存在；反之，不曾设值过，或曾用unset取消变量，
	                        则称变量不存在或未定义
	    变量设值有两种情况： 1,  其值"非空"      name='zxwtry'   name非空
	                        2,  其值为"空"      name=           name为空，以null表示
	2,  测试变量"存在与否"的基本用法：
	        语法：${待测变量-默认值}
	        判断条件：如果变量存在，传回变量的值；不存在，传回默认值。
	    执行过程如下：
				root@zxwtry:shell# name="zxwtry"
				root@zxwtry:shell# echo ${name-"default"}
				zxwtry
				root@zxwtry:shell# unset name
				root@zxwtry:shell# echo ${name-"default"}
				default
	    在script的运用中，通常将不存在和空值视为同一类的情况。
    3,  测试变量"不存在"或其值为空："传回"一个默认值：
	    语法：  ${待测变量:-默认值}
	    判断条件：  如果变量不存在或其值为空，则符合判断，传回默认值作为判断
	    用例：  myname=
	            r=${myname:-'zxwtry'}
	            echo $r
    4,  -和:-的区别：
        *   如果变量扩展的条件式中只有-这个符号，则只做变量"存在性"的判断
        *   如果变量扩展的条件式中有:-这个符号，除了判断变量"存在性"之外，多加一个变量是否存在。
    5,  拆解条件表达式：
        上述变量扩展式${变量:-默认值}，可以使用if-then-else的语法来拆解
        if [ 变量不存在 或 空值 ]; then
            传回 "默认值"
        else
            传回 "变量值"
        fi
    6,  条件式的用途
        变量扩展式${变量名称:-默认值}的主要用途是：在script周姑娘，这个变量一定要有值才行。
        因此，变量扩展的结果，一定要传回一个非空值(使用默认值或变量值)
        用例：(一定要有信件文件名)
            MSG=${filename:-"testmsg.txt"}
            cat > $MSG <<HERE
            From: im@example.edu.cn
            To: yr@example.edu.cn
            Subject: 测试一下
            这是一封测试信，请勿回复！ 
            HERE
    7,  特殊运用法
        [ -n ${DEBUG:-} ] && set -v
        [ ]是测试条件的语法。
        其中，  -n是用来测试后接的变量是否有值(测：不空)。如果非空，传回真值。
                ${DEBUG:-}就是-n要测试的对象。:-的后面本应该放置默认值的地方，没有任何东西，表示故意要默认值为空值。
        这样做的目的是：
            如果变量DEBUG非空值，那么[-n]条件测试就会成立，接着执行逻辑AND即(&&)的下一个指令：set -v，于是script就进入了查错模式；
            如果变量DEBUG没有设定或其值为空，则变量扩展的结果为空值，[-n]条件测试就会不成立，接着逻辑AND即(&&)的下一个指令不再执行，查错的功能没有打开。
            这样，切换script的查错模式就非常方便。如果要排错，就给DEBUG设一个值；否则就是正常的模式。
    8,  测试变量“不存在”或其值为空：给变量设一个默认值
        语法：${待测变量:=默认值}
        用例：  unset count
                r=${count:=100}
                echo $count
                echo $r
                //输出100 100
        用例：  count=500
                r=${count:=100}
                echo $count
                echo $r
                //输出500 500
    9,  测试变量是否"不存在"或其值为空：提示错误信息
        语法：  ${待测变量:?提示信息} 
        可以表示成拆解条件表达式
            if [ 变量不存在 或 空值 ]; then
                显示变量名称:'提示信息'
                exit
            else
                继续执行script的下一个指令
            fi
        条件式的用途:
            目的：确保某变量值一定要存在。
            如果该变量的值为空值，就显示预先准备好的错误信息，接着结束script，不再执行下去。
    11, 测试变量的"存在性"  
        语法：  ${待测变量:+真值}
        释义：  若变量存在且其值非空，则传回"真值"；若不然，传回空值
        (这里的真值，只要是非空字符串或数字都可以)
        用例：  Fighting="Coding More Code."
                r=${Fighting:+"true"}
                echo $r
                #最后输出true
        用途：  测试某件事是真的
                例如，上例中，Fighting存在，所以传回true，表示此事为真
                fgrep.sh文件内容如下：
                    #!/bin/bash
                    exec grep -F ${1+"$@"}
                说明：
                    这里使用exec执行grep程序，-F表示使用一串固定的字符串(可用换行字符分开)，作为寻找的样式。
                    其中，  ${1+"$@"}的意思是：若$1存在(指定要寻找的关键词)，则传回所有的参数。
                            $@表示fgrep.sh一次可以搜索多个文件。
                用法：
                    ./fgrep.sh Mem /proc/meminfo /root/test.txt
                由于$1=Mem非空，判断成立，因此，${1+"$@"}传回$@，此变量的值等于所有的位置参数组合起来：
                    "Mem /proc/meminfo /root/test.txt"，因此，最后exec执行的指令是：
                    grep -F Mem /proc/meminfo /root/test.txt
                    这表示，grep可由后面的两个文件去寻找关键字Mem
    12, 整理如下：
        :       空          测空值
        -       负向        测不存在
        =       设值        给空值变量设一个默认值
        ?       有问题      检查条件是否完备再来执行
        +       正向        测试存在

note10: 变量扩展：取字符串切片
    字符串编号，从0开始。
    语法一：    ${变量:位置起点}
                由指定位置开始，截取子字符串到字符串结束
                用例：
                    s="abcdefg"
                    subs=${s:1}
                    echo $subs
                执行结果是：bcdefg
    语法二：    ${变量:位置起点:长度}
    补充：      命令行参数
                例如：./test.sh x y z这指令中：
                $0:   ./test.sh
                $1:   x
                $2:   y
                $3:   z
    语法三：    ${@:起点} 
                由起点开始，取得后面所有的位置参数
                poz.sh内容如下：
                    #!/bin/bash
                    #显示命令本身
                    echo $0
                    echo ${$:1}
    语法四：    ${@:起点:个数}
                poz.sh内容如下：
                    #!/bin/bash
                    echo ${@:2:2}
                ./poz.sh 11 22 33 44
                显示22 33

note11: 变量扩展：取得字符串长度
    语法：  ${#变量名称}
            传回变量值的字符串长度
    语法：  expr length "字符串"
            用例：  str="Here you are"
                    len=$(expr length "$str")
                    echo "str字符串长度是：$len"
    语法：  expr "字符串":'.*'
            :后接的.*是一个任意多个字符的字符串样式，expr会根据此样式来对比"字符串"，等于是计算字符串的长度
            用例：  str="Here you are"
                    len=$(expr "$str":'.*')
                    echo "str字符串长度是：$len"
    比较：
            ${#变量名称}    计算字符串长度
            ${#数组[@]}     取得数组元素个数
            ${#数组[*]}     取得数组元素个数
   
note12: 变量扩展：对比样式---由字符串前面对比，删除相符者
    语法：  ${变量#样式}
            释义：由前面(最左边)开始，对比变量值，删除"最短相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename#/*/}
                    echo $r
                    显示结果：sbin/ntpdate
            用例：
                    filename="//usr/sbin/ntpdate"
                    r=${filename#/*/}
                    echo $r
                    显示结果：usr/sbin/ntpdate

    语法:   ${变量##样式}
            释义：由前面(最左边)开始，对比变量值，删除"最长相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename##/*/}
                    echo $r
                    显示结果：ntpdate

note13: 变量扩展：对比样式---由字符串后面对比，删除相符者
    语法：  ${变量%样式}
            释义：由后面(最右边)开始，对比变量值，删除"最短相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename%/*/}
                    echo $r
                    显示结果：/usr/sbin/ntpdate
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename%/*}
                    echo $r
                    显示结果：/usr/sbin

    语法:   ${变量##样式}
            释义：由后面(最右边)开始，对比变量值，删除"最长相符合的字符串"
            用例：
                    example="www.example.edu.cn"
                    m=${example%%.*}
                    echo $m
                    输出结果：www

note14: 变量扩展：对比样式---取代或删除部分字符串
    语法：  ${变量/样式/替换字符串}     ---值替换第一个
    释义：  若变量中，有符合样式的字符串(取最长的)，则使用替换字符串予以取代
            用例：
                    act="mail:x:8:"
                    r=${act/:/,}
                    echo $r
                    输出：mail,x:8:
    语法：  ${变量//样式/替换字符串}     ---值替换全部
    释义：  若变量中，有符合样式的字符串(取最长的)，则使用替换字符串予以取代
            用例：
                    act="mail:x:8:"
                    r=${act//:/,}
                    echo $r
                    输出：mail,x,8,

note15: 变量扩展：对比样式---把对比符合的字符串删除
    语法：  ${变量/样式/}
    释义：  删除第一个符合样式的字符串，只删一个
            用例：
                    act="mail:x:8:8:mail:/var/mail:/bin/sh"
                    r=${act/:/}
                    echo $r
                    执行结果：第一个:删除后的样子。
                    mailx:8:8:mail:/var/mail:/bin/sh
    语法：  ${变量//样式/}
    释义：  删除所有符合样式的字符串，全部删除
            用例：
                    act="mail:x:8:8:mail:/var/mail:/bin/sh"
                    r=${act/:/}
                    echo $r
                    执行结果：所有:删除后的样子。
                    mailx88mail/var/mail/bin/sh

note16: 变量扩展：对比样式---要求样式在句首或句尾
    在对比样式时，若在样式前加上#，如#T，则该样式要出现在变量值的开头才算符合。
            用例：
                    str="Yes, This is a Title."
                    r=${str/#T* /}
                    echo $r
                    执行结果：Yes, This is a Title.
            用例：
                    str="Yes, This is a Title."
                    r=${str/T* /}
                    echo $r
                    执行结果：Yes, Title.
            用例：
                    str="Tony , This is Joy."
                    r=${str/#T* /}
                    echo $r
                    执行结果：Joy.

note17: 变量扩展：对比样式---小整理
        语法                        用途
    1,  ${变量/样式/替换字符串}     替换第一个对比符合的字符串
    2,  ${变量//样式/替换字符串}    替换全部对比符合的字符串
    3,  ${变量/#样式/替换字符串}    替换第一个对比符合的字符串，由变量值开头对比
    4,  ${变量/%样式/替换字符串}    替换第一个对比符合的字符串，由变量值尾部对比
    5,  ${变量/样式/}               删除第一个对比符合的字符串
    6,  ${变量//样式/}              删除所有对比符合的字符串
    7,  ${变量/#样式/}              删除第一个对比符合的字符串，由变量值开头对比
    8,  ${变量/%样式/}              删除第一个对比符合的字符串，由变量值尾部对比

note18: 变量扩展：取变量名称列表、数组索引列表
    取变量名称列表：
        语法：  ${!开头字符串@} 或 ${!开头字符串*}
        释义：  把所有以指定字符串开头的变量名称列出，各变量之间，用$IFS定义的
                第一个分隔字符(通常是空格符)隔开。
        用例：  
                filename="ntpdate"
                dir="/usr/sbin"
                dir_file="$dir/$filename"
                echo ${!di@}
                执行结果：dir dir_file
    取数组索引列表：
        语法：  ${!数组变量[@]} 或 ${!数组变量[*]}
        释义：  把数组变量所有的索引列出，各索引值之间，用$IFS定义的第一个分隔字符
                (通常是空格符)隔开。
        用例：
                ar=(a b c xy z)
                r=${!ar[@]}
                echo $r
                执行结果：0 1 2 3 4
    注意：
        1,  取数组索引列表，只有在Bash 3以后的版本才支持，Bash 2没有。
        2,  如果扩展式使用@符号，并且出现在双引号中，如，${!数组变量[@]}，
            则其传回的不是一个字符串，而是将索引值各视为单独的字符串。
            用例：
                    ar=(a b c xy z)
                    for i in "${!ar[@]}"
                    do
                        echo "index $i: ${ar[Si]}"
                    done
                    执行结果：
                    index 0: a
                    index 1: b
                    index 2: c
                    index 3: xy
                    index 4: z
    
note19: 命令替换
    释义：  把命令执行后的标准输出放入变量中。
    举例：  想查看工作目录中所有的文件名，可执行ls命令。
            如何把这些文件名存入变量中，供往后的程序代码再利用？
            使用命令替换。
    语法：  
            新式的写法：    变量名称=$(命令) 
            旧式的写法：    变量名称=`命令`
    说明：  
            Bash会把执行命令后产生的标准输出，赋值给指定的变量。
            在这个过程中，默认会自动删除换行字符。
            (举例中的问题，只需要执行： dirs=$(ls))
    用例：
            dirs=$(ls)
            for f in $dirs
            do
                echo $f
            done
    用例：
            file="/home/zxwtry/.bash/id_rsa"
            IFS=' '
            fc=$(cat $file)
            echo $fc
            (由于IFS改用空格符，变量扩展时，换行字符不会删除，
            这样才能保持该文件的内容。。。如果不改设FIS，则
            passwd的每行会去掉换行字符，变成一个以空格符隔开
            各行的字符串。)
            (行3若改成fc=$(<$file)，效果是一样的。这是使用
            转向输入取得文件内容，再扩展成变量内容放入fc中。)
            (在变量替换中，可以包含两个或两个以上的指令，
            如，可取得上层目录的名称：PDIR=$(cd ..;pwd)
            这里有两道指令；cd ..和pwd，中间用;隔开，命令替换
            的值是最后一道指令执行的结果。)
            (在命令替换里面，也可以包含其他命令替换。例如：
            r=$(du -s $(pwd))可取得工作目录占用磁盘用量的总和。)
    用例：
            #!/bin/bash
            tmp=$(ifconfig | grep 'inet addr')
            r=${tmp/inet addr:/}
            ip=${r/ Bcast*/}
            echo $ip
            执行结果：输出：ip

note20: 算术扩展
    用例：
            执行如下片段：
                I=8+16
                echo $I
            执行结果：输出8+16
    语法：  算术扩展的语法：    $((算术式))
    用例：  
            I=$((8+16))
            echo $I
            执行结果：输出24
            I=$(8+16)
            执行出错，8+16: command not found

note21: 算术运算---之前提到的算术扩展
    名称            语法            范例
    算术扩展        $((算术符))     r=$((2+5*8))
    使用外部命令    expr算术式      r=`expr 4+5`
    expr            
    使用$[]         $[算术式]       r=$[4+5]
    使用内置命令    declare -i 变量=算术式
    declare         declare -i r=8+16
    使用内置命令    let 算术式      let r=8+16
    let

note22: 算术运算---简介
    1,  算术式由运算符和操作数，扩展式会先展开
        用例：  
                echo $((${j:-8}+2))
                如果j不存在或为空，输出10
                如果j存在且是数字，输出j+2
                如果j存在且是字符串形式，输出2
                如果j存在且是1.23小数形式，运行出错。
                (具体见代码：code019_算术运算_简介.sh)
    2,  在求值时，如果算术式中变量不存在或者为空值，该变量值为0
        用例：
                echo $((k+4))
                执行结果：输出：4
	3,	如果数字以0开头，则视为八进制数字。
		用例：
				016等于十进制数14
	4,	以0x或0X开头，视为16进制数字。
		用例：
				0x2a等于十进制的42
	5,	不同进制的数字，可使用"基底#数字"的表示法，其中基底范围为2~64。
		如果数字超过9，则以a代表10，以b代表11，依次类推。
		用例：
				十五进制数15#1b，其值为：1*15+11=26。
				二进制数2#1010，其值为：1*8+0*4+1*2+0*1=10。

