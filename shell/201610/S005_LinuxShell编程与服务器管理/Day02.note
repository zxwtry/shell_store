note01: 自定义环境之以一般账户的角色工作时
    Bash Shell的启动配置文件中曾提到Bash Shell的启动配置文件。
    这种机制为用户提供自定义工作环境的弹性。使用者可比较启动配置文件，
    安排方便工作的环境。
    可自定义的配置文件，如下表所示：
        文件名                  时机
        ~/.bash_profile         登录时
        ~/.bashrc               执行新shell时
        ~/.bash_logout          注销时
        (这里的~指的是家目录)
    大多数主机在开设账号后，会自动在用户家目录中建立.bash_profile和.bashrc两个文件。
    而.bash_logout一般默认没有，需由用户自己建立。
    自定义环境的主要目的是要让用户登录主机时，能拥有安全及易于执行命令的环境，项目包括：建立文件的权限、命令搜寻路径、环境变量、命令提示符、别名、喜好的比较器、显示文件使用的颜色等。
    一般在.bash_profile设定可以一体使用的命令、搜寻路径及环境变量，而把其他大部分的设定放在.bashrc。因此.bash_profile文件比较小，.bashrc则比较大。
    建议：自定义.bash_profile时，仍然依循上述惯例，让它越简单越好。
          这样不但好维护，而且不易出错。
    以下是.bash_profile的设定范例
            #设定umask
            umask 022
            #登录后，也执行一个.bashrc
            if [ -f ~/.bashrc ]; then
                . ~/.bashrc
            fi
            #设定自己专用的程序路径
            if [ -d ~/bin ]; then
                PATH=~/bin:$PATH
            fi
            #设定CVS环境
            export CVSROOT=":pserver:zxwtry@192.168.1.2:/home/zxwtry"
            #设定Java环境
            export JAVA_HOME=~/jdk/bin
            export PATH=$PATH:$JAVA_HOME
        行2，设定新建文件、目录的安全权限，分别是644及755(即用666和777各减去022)
    以下是.bashrc的设定范例：
            #判断若不是在互动模式，则不执行.bashrc
            [ -z "$PS1" ] && return
            #设定有颜色的提示
            PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
            #设定方便使用的程序别名
            alias ll='ls -alF'
            alias la='ls -A'
            alias l='ls -CF'
            #如果系统没有启用bash_completion，可在这里启用
            if [ -f /usr/share/bash-completion/bash_completion ]; then
                . /usr/share/bash-completion/bash_completion
            elif [ -f /etc/bash_completion ]; then
                . /etc/bash_completion
            fi
            #重复的命令、ls、bg、fg、exit、ps等指令，不存入历史日志文件中。
            export HISTIGNORE="&:ls:ls *:[bf]g:exit:ps *"
            #设定自己常用的目录，可用cd指令快速切换
            export CDPATH=.:~:~/docs:~/src:~/tmp:/mnt:/usr/src:/usr/lib:/usr/local
    以下是.bash_logout的设定范例
            #注销时，清空tmp目录中的所有内容
            rm -rf ~/tmp/*

note02: 自定义环境---以系统管理员的角色工作时
    系统管理员维护的环境配置文件，主要有3个：
        1,  /etc/profile
        2,  /etc/bash.bashrc
        3,  /etc/skel 目录下所有文件
    前两个文件的用途，在Bash Shell的启动配置文件中已经说明。
    /etc/profile和/etc/bash.bashrc的设定，会影响所有账号的使用环境，因此，要特别小心。
    在/etc/profile中，通常会做如下设定：umask, PATH, 多国语言环境, 提示符号, 别名等等。
    bash.bashrc的内容，大多如下：
        [ -f /etc/profile ] && . /etc/profile
        这表明，当执行交互式的Shell时会检查/etc/profile是否存在，若存在，就执行它。这样的做法，等于是让管理员只要维护一份全局的/etc/profile配置文件即可。
    除了这两个文件，/etc/skel这个目录也很重要。它的作用是，当管理员开设新账户时，账号管理程序会把/etc/skel中的所有文件复制一份放到家目录中，作为用户的环境文件。
    
note03: 数组
    bash数组，其元素的个数没有限制，数组的索引由0开始，但不一定要连续，(可以跳号)。
    索引号也可以用算术表达式表示，如1+2
    bash 3.x只支持一维数组(关系型数组在Bash4.0才支持) 
    用例：
            root@zxwtry:~# A[0]=1
            root@zxwtry:~# A[0]='c'
            root@zxwtry:~# A[0]="good"
            root@zxwtry:~# echo ${A[1]}
            
            root@zxwtry:~# echo ${A[0]}
            good
            root@zxwtry:~# A[3]=1
            root@zxwtry:~# echo ${B[@]}
            
            root@zxwtry:~# echo ${A[@]}
            good 1
            root@zxwtry:~# echo ${A[*]}
            good 1
            root@zxwtry:~# echo ${#A[*]}
            2
            root@zxwtry:~# echo ${#A[@]}
            2
    ${A[@]} --- 一次取出所有的元素：得到以空白隔开的东东
    ${A[*]} --- 一次取出所有的元素：得到一整个字符串
    ${#A[@]} 或者 ${#A[*]} --- 得到数组的元素
    ${#数组[索引]}  --- 如果数组元素是字符串，得到字符串的长度
    unset A --- 取消数组
    unset A[3]  --- 取消某一个元素，取消了第4个元素

note04: Here Document --- 用Here Document设定变量
    bash有一种特殊的程序区域，叫Here Document，也可以用来设定变量。
    Here Document的基本语法：
        命令 <<标记
        ......
        ......
        ......
        标记
    这样会吧命令和标记之间的内容，利用转向输入的方式交给命令去处理。
    标记可以是任何字符串。选用标记的原则：尽量选不常用的字符组合，
        避免该字符串出现在输入的内容中造成bash预判。
    范例如下：
        wc -l <<HERE
        line 1
        line 2
        line 3
        HERE
        (经由wc计算结果得到3行)
    Here Document也支持变量替换。在输入的内容中，如果有变量，bash在转向前会先替换变量值
        From="From: me@example.edu.cn"    
        To="To: you@example.edu.cn"
        Subject="Subject: hello world"
        Msg="吃饭睡觉"
        Em="20161101.txt"
        cat > $Em <<HERE
        $From
        $To
        $Subject
        
        $Msg
        HERE
    执行结果如下：
        root@zxwtry:S005_LinuxShell编程与服务器管理# chmod +x code011_Here_Document_变量替换.sh 
        root@zxwtry:S005_LinuxShell编程与服务器管理# ./code011_Here_Document_变量替换.sh 
        root@zxwtry:S005_LinuxShell编程与服务器管理# cat 20161101.txt 
        From: me@example.edu.cn
        To: you@example.edu.cn
        Subject: hello world
        
        吃饭睡觉
    Here Document的变量设定
        WOW="WOW, great!"
        var=$(cat <<HERE
        Line 1 is good
        They are tencent, alibaba and baidu.
        $WOW
        HERE)
        echo $var
    执行结果如下：
        root@zxwtry:S005_LinuxShell编程与服务器管理# ./code012_Here_Document_变量设定.sh 
        ./code012_Here_Document_变量设定.sh: line 12: warning: here-document at line 8 delimited by end-of-file (wanted `HERE')
        Line 1 is good They are tencent, alibaba and baidu. WOW, great!
    替换$WOW的变量值之后转向输出，交给cat显示出来，其结果放置在$()中进行替换变量，得到上述结果。
    在标记加上双引号也是可以的，例如上例写成$(cat <<"HERE")，表示这个Here Document拥有和双引号一样的特性，即支持变量替换的功能。

note05: Here Document   --- 控制Here Document的格式
    Here Document支持两种控制输出格式的做法：
    1,  关闭变量替换的功能
        有时候，希望按照原本的样子转向输出，不做任何变量替换。做法如下：
            cat <<'HERE'
            Line 1 is good
            They are tencent, alibaba, and baidu.
            $WOW
            HERE
        行1中，对标记HERE加上单引号，即可关闭变量替换。
        执行结果：
            Line 1 is good
            They are tencent, alibaba, and baidu.
            $WOW
        $WOW还是保持原样，不做变量替换。
    2,  去掉每行之前的TAB字符：
            cat <<-'HERE'
                Line 1 is good.
                They are tencent, alibaba, and baidu.
                $WOW
            HERE
        行2~4每行前面都有一个TAB字符。行1在标记前加上-，表示要抑制各行首TAB的作用，输出结果同前例。

note06: Here Document   --- 利用Here Document做多行批注
    用例：
        : <<DO-NOTTHING
        这是第一行批注
        这是第二行批注
        这是第三行批注
        这是第四行批注
        DO-NOTTHING
        :代表"什么都不做"的空命令。这个区域在script中，bash会忽略不执行，因此，达到批注的效果。

note07: Here Document   --- 利用Here Document，打包C(或其他程序语言)的原始码
    这是Cracker散步安全漏洞时，最喜欢的用法。举例如下：
    代码在：code013_Here_Document_打包C的原始码.sh    
            #!/bin/bash
            echo "正在产生 hello.c...."
            echo
            cat <<'EOF' > hello.c
            #include <stdio.h>
            int main(){
                printf("hello world!\n");
                return 0;
            }
            EOF
            echo "编译hello.c..."
            echo
            #编译hello.c，产生执行文件
            gcc -o hello hello.c
            #若编译成功，就执行
            if [ $? -eq 0 ]; then
                echo "执行hello..."
                echo
                ./hello
            else
                echo 'Compile ERROR: hello.c'
            fi
    执行结果如下：
            root@zxwtry:S005_LinuxShell编程与服务器管理# ./code013_Here_Document_打包C的原始码.sh 
            正在产生 hello.c....
            
            编译hello.c...
            
            执行hello...
            
            hello world!
    这个script利用Here Document，夹带了一个hello.c程序的原始码，执行本script时会产生hello.c，
        接着利用gcc编译hello.c，若编译无误，就执行程序文件hello
    这就是shell script携带攻击程序的原型。

note08: 高级变量
    高级变量，有3个主题：
        1,  变量扩展
        2,  命令替换
        3,  算术扩展
    ${变量名称}     ---     变量替换    ---     ${filename}
    $(命令)         ---     命令替换    ---     $(ls /)
    $((算术式))     ---     算术扩展    ---     $((9+9))

note09: 变量扩展：测试存在性及空值
    1,  基本型：${变量名称} 
        "变量存在"的定义：   如果变量曾设值过，则称该变量存在；反之，不曾设值过，或曾用unset取消变量，
                            则称变量不存在或未定义
        变量设值有两种情况： 1,  其值"非空"      name='zxwtry'   name非空
                            2,  其值为"空"      name=           name为空，以null表示
    2,  测试变量"存在与否"的基本用法：
            语法：${待测变量-默认值}
            判断条件：如果变量存在，传回变量的值；不存在，传回默认值。
        执行过程如下：
                root@zxwtry:shell# name="zxwtry"
                root@zxwtry:shell# echo ${name-"default"}
                zxwtry
                root@zxwtry:shell# unset name
                root@zxwtry:shell# echo ${name-"default"}
                default
        在script的运用中，通常将不存在和空值视为同一类的情况。
    3,  测试变量"不存在"或其值为空："传回"一个默认值：
        语法：  ${待测变量:-默认值}
        判断条件：  如果变量不存在或其值为空，则符合判断，传回默认值作为判断
        用例：  myname=
                r=${myname:-'zxwtry'}
                echo $r
    4,  -和:-的区别：
        *   如果变量扩展的条件式中只有-这个符号，则只做变量"存在性"的判断
        *   如果变量扩展的条件式中有:-这个符号，除了判断变量"存在性"之外，多加一个变量是否存在。
    5,  拆解条件表达式：
        上述变量扩展式${变量:-默认值}，可以使用if-then-else的语法来拆解
        if [ 变量不存在 或 空值 ]; then
            传回 "默认值"
        else
            传回 "变量值"
        fi
    6,  条件式的用途
        变量扩展式${变量名称:-默认值}的主要用途是：在script周姑娘，这个变量一定要有值才行。
        因此，变量扩展的结果，一定要传回一个非空值(使用默认值或变量值)
        用例：(一定要有信件文件名)
            MSG=${filename:-"testmsg.txt"}
            cat > $MSG <<HERE
            From: im@example.edu.cn
            To: yr@example.edu.cn
            Subject: 测试一下
            这是一封测试信，请勿回复！ 
            HERE
    7,  特殊运用法
        [ -n ${DEBUG:-} ] && set -v
        [ ]是测试条件的语法。
        其中，  -n是用来测试后接的变量是否有值(测：不空)。如果非空，传回真值。
                ${DEBUG:-}就是-n要测试的对象。:-的后面本应该放置默认值的地方，没有任何东西，表示故意要默认值为空值。
        这样做的目的是：
            如果变量DEBUG非空值，那么[-n]条件测试就会成立，接着执行逻辑AND即(&&)的下一个指令：set -v，于是script就进入了查错模式；
            如果变量DEBUG没有设定或其值为空，则变量扩展的结果为空值，[-n]条件测试就会不成立，接着逻辑AND即(&&)的下一个指令不再执行，查错的功能没有打开。
            这样，切换script的查错模式就非常方便。如果要排错，就给DEBUG设一个值；否则就是正常的模式。
    8,  测试变量“不存在”或其值为空：给变量设一个默认值
        语法：${待测变量:=默认值}
        用例：  unset count
                r=${count:=100}
                echo $count
                echo $r
                //输出100 100
        用例：  count=500
                r=${count:=100}
                echo $count
                echo $r
                //输出500 500
    9,  测试变量是否"不存在"或其值为空：提示错误信息
        语法：  ${待测变量:?提示信息} 
        可以表示成拆解条件表达式
            if [ 变量不存在 或 空值 ]; then
                显示变量名称:'提示信息'
                exit
            else
                继续执行script的下一个指令
            fi
        条件式的用途:
            目的：确保某变量值一定要存在。
            如果该变量的值为空值，就显示预先准备好的错误信息，接着结束script，不再执行下去。
    11, 测试变量的"存在性"  
        语法：  ${待测变量:+真值}
        释义：  若变量存在且其值非空，则传回"真值"；若不然，传回空值
        (这里的真值，只要是非空字符串或数字都可以)
        用例：  Fighting="Coding More Code."
                r=${Fighting:+"true"}
                echo $r
                #最后输出true
        用途：  测试某件事是真的
                例如，上例中，Fighting存在，所以传回true，表示此事为真
                fgrep.sh文件内容如下：
                    #!/bin/bash
                    exec grep -F ${1+"$@"}
                说明：
                    这里使用exec执行grep程序，-F表示使用一串固定的字符串(可用换行字符分开)，作为寻找的样式。
                    其中，  ${1+"$@"}的意思是：若$1存在(指定要寻找的关键词)，则传回所有的参数。
                            $@表示fgrep.sh一次可以搜索多个文件。
                用法：
                    ./fgrep.sh Mem /proc/meminfo /root/test.txt
                由于$1=Mem非空，判断成立，因此，${1+"$@"}传回$@，此变量的值等于所有的位置参数组合起来：
                    "Mem /proc/meminfo /root/test.txt"，因此，最后exec执行的指令是：
                    grep -F Mem /proc/meminfo /root/test.txt
                    这表示，grep可由后面的两个文件去寻找关键字Mem
    12, 整理如下：
        :       空          测空值
        -       负向        测不存在
        =       设值        给空值变量设一个默认值
        ?       有问题      检查条件是否完备再来执行
        +       正向        测试存在

note10: 变量扩展：取字符串切片
    字符串编号，从0开始。
    语法一：    ${变量:位置起点}
                由指定位置开始，截取子字符串到字符串结束
                用例：
                    s="abcdefg"
                    subs=${s:1}
                    echo $subs
                执行结果是：bcdefg
    语法二：    ${变量:位置起点:长度}
    补充：      命令行参数
                例如：./test.sh x y z这指令中：
                $0:   ./test.sh
                $1:   x
                $2:   y
                $3:   z
    语法三：    ${@:起点} 
                由起点开始，取得后面所有的位置参数
                poz.sh内容如下：
                    #!/bin/bash
                    #显示命令本身
                    echo $0
                    echo ${$:1}
    语法四：    ${@:起点:个数}
                poz.sh内容如下：
                    #!/bin/bash
                    echo ${@:2:2}
                ./poz.sh 11 22 33 44
                显示22 33

note11: 变量扩展：取得字符串长度
    语法：  ${#变量名称}
            传回变量值的字符串长度
    语法：  expr length "字符串"
            用例：  str="Here you are"
                    len=$(expr length "$str")
                    echo "str字符串长度是：$len"
    语法：  expr "字符串":'.*'
            :后接的.*是一个任意多个字符的字符串样式，expr会根据此样式来对比"字符串"，等于是计算字符串的长度
            用例：  str="Here you are"
                    len=$(expr "$str":'.*')
                    echo "str字符串长度是：$len"
    比较：
            ${#变量名称}    计算字符串长度
            ${#数组[@]}     取得数组元素个数
            ${#数组[*]}     取得数组元素个数
   
note12: 变量扩展：对比样式---由字符串前面对比，删除相符者
    语法：  ${变量#样式}
            释义：由前面(最左边)开始，对比变量值，删除"最短相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename#/*/}
                    echo $r
                    显示结果：sbin/ntpdate
            用例：
                    filename="//usr/sbin/ntpdate"
                    r=${filename#/*/}
                    echo $r
                    显示结果：usr/sbin/ntpdate

    语法:   ${变量##样式}
            释义：由前面(最左边)开始，对比变量值，删除"最长相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename##/*/}
                    echo $r
                    显示结果：ntpdate

note13: 变量扩展：对比样式---由字符串后面对比，删除相符者
    语法：  ${变量%样式}
            释义：由后面(最右边)开始，对比变量值，删除"最短相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename%/*/}
                    echo $r
                    显示结果：/usr/sbin/ntpdate
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename%/*}
                    echo $r
                    显示结果：/usr/sbin

    语法:   ${变量##样式}
            释义：由后面(最右边)开始，对比变量值，删除"最长相符合的字符串"
            用例：
                    example="www.example.edu.cn"
                    m=${example%%.*}
                    echo $m
                    输出结果：www

note14: 变量扩展：对比样式---取代或删除部分字符串
    语法：  ${变量/样式/替换字符串}     ---值替换第一个
    释义：  若变量中，有符合样式的字符串(取最长的)，则使用替换字符串予以取代
            用例：
                    act="mail:x:8:"
                    r=${act/:/,}
                    echo $r
                    输出：mail,x:8:
    语法：  ${变量//样式/替换字符串}     ---值替换全部
    释义：  若变量中，有符合样式的字符串(取最长的)，则使用替换字符串予以取代
            用例：
                    act="mail:x:8:"
                    r=${act//:/,}
                    echo $r
                    输出：mail,x,8,

note15: 变量扩展：对比样式---把对比符合的字符串删除
    语法：  ${变量/样式/}
    释义：  删除第一个符合样式的字符串，只删一个
            用例：
                    act="mail:x:8:8:mail:/var/mail:/bin/sh"
                    r=${act/:/}
                    echo $r
                    执行结果：第一个:删除后的样子。
                    mailx:8:8:mail:/var/mail:/bin/sh
    语法：  ${变量//样式/}
    释义：  删除所有符合样式的字符串，全部删除
            用例：
                    act="mail:x:8:8:mail:/var/mail:/bin/sh"
                    r=${act/:/}
                    echo $r
                    执行结果：所有:删除后的样子。
                    mailx88mail/var/mail/bin/sh

note16: 变量扩展：对比样式---要求样式在句首或句尾
    在对比样式时，若在样式前加上#，如#T，则该样式要出现在变量值的开头才算符合。
            用例：
                    str="Yes, This is a Title."
                    r=${str/#T* /}
                    echo $r
                    执行结果：Yes, This is a Title.
            用例：
                    str="Yes, This is a Title."
                    r=${str/T* /}
                    echo $r
                    执行结果：Yes, Title.
            用例：
                    str="Tony , This is Joy."
                    r=${str/#T* /}
                    echo $r
                    执行结果：Joy.

note17: 变量扩展：对比样式---小整理
        语法                        用途
    1,  ${变量/样式/替换字符串}     替换第一个对比符合的字符串
    2,  ${变量//样式/替换字符串}    替换全部对比符合的字符串
    3,  ${变量/#样式/替换字符串}    替换第一个对比符合的字符串，由变量值开头对比
    4,  ${变量/%样式/替换字符串}    替换第一个对比符合的字符串，由变量值尾部对比
    5,  ${变量/样式/}               删除第一个对比符合的字符串
    6,  ${变量//样式/}              删除所有对比符合的字符串
    7,  ${变量/#样式/}              删除第一个对比符合的字符串，由变量值开头对比
    8,  ${变量/%样式/}              删除第一个对比符合的字符串，由变量值尾部对比

note18: 变量扩展：取变量名称列表、数组索引列表
    取变量名称列表：
        语法：  ${!开头字符串@} 或 ${!开头字符串*}
        释义：  把所有以指定字符串开头的变量名称列出，各变量之间，用$IFS定义的
                第一个分隔字符(通常是空格符)隔开。
        用例：  
                filename="ntpdate"
                dir="/usr/sbin"
                dir_file="$dir/$filename"
                echo ${!di@}
                执行结果：dir dir_file
    取数组索引列表：
        语法：  ${!数组变量[@]} 或 ${!数组变量[*]}
        释义：  把数组变量所有的索引列出，各索引值之间，用$IFS定义的第一个分隔字符
                (通常是空格符)隔开。
        用例：
                ar=(a b c xy z)
                r=${!ar[@]}
                echo $r
                执行结果：0 1 2 3 4
    注意：
        1,  取数组索引列表，只有在Bash 3以后的版本才支持，Bash 2没有。
        2,  如果扩展式使用@符号，并且出现在双引号中，如，${!数组变量[@]}，
            则其传回的不是一个字符串，而是将索引值各视为单独的字符串。
            用例：
                    ar=(a b c xy z)
                    for i in "${!ar[@]}"
                    do
                        echo "index $i: ${ar[Si]}"
                    done
                    执行结果：
                    index 0: a
                    index 1: b
                    index 2: c
                    index 3: xy
                    index 4: z
    
note19: 命令替换
    释义：  把命令执行后的标准输出放入变量中。
    举例：  想查看工作目录中所有的文件名，可执行ls命令。
            如何把这些文件名存入变量中，供往后的程序代码再利用？
            使用命令替换。
    语法：  
            新式的写法：    变量名称=$(命令) 
            旧式的写法：    变量名称=`命令`
    说明：  
            Bash会把执行命令后产生的标准输出，赋值给指定的变量。
            在这个过程中，默认会自动删除换行字符。
            (举例中的问题，只需要执行： dirs=$(ls))
    用例：
            dirs=$(ls)
            for f in $dirs
            do
                echo $f
            done
    用例：
            file="/home/zxwtry/.bash/id_rsa"
            IFS=' '
            fc=$(cat $file)
            echo $fc
            (由于IFS改用空格符，变量扩展时，换行字符不会删除，
            这样才能保持该文件的内容。。。如果不改设FIS，则
            passwd的每行会去掉换行字符，变成一个以空格符隔开
            各行的字符串。)
            (行3若改成fc=$(<$file)，效果是一样的。这是使用
            转向输入取得文件内容，再扩展成变量内容放入fc中。)
            (在变量替换中，可以包含两个或两个以上的指令，
            如，可取得上层目录的名称：PDIR=$(cd ..;pwd)
            这里有两道指令；cd ..和pwd，中间用;隔开，命令替换
            的值是最后一道指令执行的结果。)
            (在命令替换里面，也可以包含其他命令替换。例如：
            r=$(du -s $(pwd))可取得工作目录占用磁盘用量的总和。)
    用例：
            #!/bin/bash
            tmp=$(ifconfig | grep 'inet addr')
            r=${tmp/inet addr:/}
            ip=${r/ Bcast*/}
            echo $ip
            执行结果：输出：ip

note20: 算术扩展
    用例：
            执行如下片段：
                I=8+16
                echo $I
            执行结果：输出8+16
    语法：  算术扩展的语法：    $((算术式))
    用例：  
            I=$((8+16))
            echo $I
            执行结果：输出24
            I=$(8+16)
            执行出错，8+16: command not found

note21: 算术运算---之前提到的算术扩展
    名称            语法            范例
    算术扩展        $((算术符))     r=$((2+5*8))
    使用外部命令    expr算术式      r=`expr 4+5`
    expr            
    使用$[]         $[算术式]       r=$[4+5]
    使用内置命令    declare -i 变量=算术式
    declare         declare -i r=8+16
    使用内置命令    let 算术式      let r=8+16
    let

note22: 算术运算---简介
    1,  算术式由运算符和操作数，扩展式会先展开
        用例：  
                echo $((${j:-8}+2))
                如果j不存在或为空，输出10
                如果j存在且是数字，输出j+2
                如果j存在且是字符串形式，输出2
                如果j存在且是1.23小数形式，运行出错。
                (具体见代码：code019_算术运算_简介.sh)
    2,  在求值时，如果算术式中变量不存在或者为空值，该变量值为0
        用例：
                echo $((k+4))
                执行结果：输出：4
    3,  如果数字以0开头，则视为八进制数字。
        用例：
                016等于十进制数14
    4,  以0x或0X开头，视为16进制数字。
        用例：
                0x2a等于十进制的42
    5,  不同进制的数字，可使用"基底#数字"的表示法，其中基底范围为2~64。
        如果数字超过9，则以a代表10，以b代表11，依次类推。
        用例：
                十五进制数15#1b，其值为：1*15+11=26。
                二进制数2#1010，其值为：1*8+0*4+1*2+0*1=10。
    6,  Bash运算符的优先级表：
        优先级      运算符
        1           i++　   i--
        2           ++i     --i
        3           -负号   +正号
        4           !逻辑'非'   ~位取反
        5           **乘方
        6           *乘  /除  %取余
        7           +加  -减
        8           <<位向左移   >>
        9           <=  >=  >  < 
        10          ==   !=
        11          & 位的AND
        12          ^ 位的互斥？？？？？？？
        13          | 位的OR
        14          && 逻辑的AND
        15          || 逻辑的OR
        16          '?:'三目运算符
        17          = *= /= %= += -= <<= >>= &= ^= |=
        18          '式子1，式子2'逗号运算
        (小括号可改变运算的优先级)

note23: 算术扩展的补充：
    算术扩展的语法：    $((表达式))
    如果表达式中有变量，该变量名称之前最好不要加上$这个符号，
    用来避免该变量不存在造成语法的错误。
    用例：
            unset i
            echo $((12+$i))
            运行结果：  语法错误
    用例：
            unset i
            echo $((12+i))
            运行结果：  12
    小结：
            $((12+i))           正确范例
            $((12+$i))          当i不存在时，语法错误，不建议使用
            $((12+${i}))        当i不存在时，语法错误，不建议使用
            $((12+${j:-8}))     表达式中有"变量扩展"的正确范例

note24: 使用外部程序expr做算术运算
    外部程序expr本来的作用，是在"标准输出"显示表达式的值
    语法：
            expr 3+2
            输出结果：  3+2
            expr 3 + 2
            输出结果：  5
    特点：
            如果注重跨平台、可移植，在Script程序的开发中可使用expr替代其他算术运算。
    注意：
            注意，"表达式"中是否含有bash shell的特殊字符，例如*、|、<、>、!、&、(、)等。如果有的话，要用\进行转义。
    语法：
            r=`expr 参数1 \| 参数2`
            (|代表或。如果"参数1"存在，非空，不是0，则传回"参数1"的值；、
            否则，传回"参数2"的值。)
            用例：
                    r=`expr 3 \| 0`
                    echo $r
                    执行结果：  输出3
            用例：
                    r=`expr 0 \| 2`
                    echo $r
                    执行结果：  输出2
    语法：
            r=`expr 参数1 \& 参数2`
            如果"参数1"和"参数2"皆存在、非空、不是0，则传回"参数1"的值，否则传回0
            用例：
                    r=`expr 3 \& 0`
                    echo $r
                    执行结果：  输出0
    比较：
            算式                        比较式是否成立      r值
            r=`expr 1 \< 2`             是                  1
            r=`expr 3 \<= 2`            否                  0
            r=`expr 2 == 2`             是                  1
            r=`expr 3 \!= 2`            是                  1
            r=`expr 3 \>= 2`            是                  1
            r=`expr 3 \> 2`             是                  1
    加：
            r=`expr 4 + 5`
            echo $r
            执行结果：  输出9
            r=`expr 4+5`
            echo $r
            执行结果：  输出4+5
    乘：
            需要 \*
    除：
            /
    乘方：
            expr没有乘幂功能，`expr 2**3`是错误的。

note25: 使用$[]做算术运算
    与$(())类似
    用例：
            r=$[4+5]
            echo $r
            执行结果：  输出9
    用例：
            r=$[2**3]
            echo $r
            执行结果：  输出8


note26: 使用内置命令declare、let作算术运算
    用例：
            declare -i I
            I=8+16
            echo $I
            执行结果：  输出24
            (表示，使用declare将I设置成整数，保存的不再是字符串)
    特点：
            1,  运算符和操作数之间，不能有空格符，而要紧密连接
            2,  特殊符号不必使用\转义，例如乘法*，乘方**
            3,  算式中，可包含其他变量，变量之前不必加上$
    用例；
            declare -i I
            I=8+16
            I=16-8
            I=5*3
            I=22/5
            I=2**3
            I=100%43
            declare -i J
            J=I+1
    特点：
            1,  let在算术运算的用法，基本和declare类似 
            2,  可以使用空格符，让表达式可读性更高，但必须使用引号才行：
                let "i = i + 5"
                let "n = i <20 ? 1 : 0"

note27: 流程控制---命令的结束状态
    1， Bash Shell中，流程控制命令有两大类："选择"和"循环"
    2,  "选择"的有：if 、case、select
    3,  "循环"的有：for、while、until、select
    4,  每一个命令执行后，都会传回一个结束状态值。
        成功：返回0
    
note28: 流程控制---if 
    1,  if-then-else
        if 条件测试; then
            命令区域
        fi
            用例：
                if (( 2 < 10 )); then
                    echo "真"  
                fi
            用例：
                if (( 2 < 10 )); then echo "真"; fi
    2,  if-then-else
        if 条件测试; then
            命令区域
        else
            命令区域2
        fi
    3,  if-then-elif-else
        if 条件测试1; then
            命令区域1
        elif 条件测试2; then
            命令区域2
        else
            命令区域3
        fi
    4,  (())是Bash的复合命令，内置算式
        可以使用let ""代替
        见code21_if_let.sh和code21_if_双括号.sh

note28: 条件测试的写法
    1,  执行某一个命令的结果：
        这里的命令，可包括管道命令，例如：命令1 | 命令2 | 命令3
        其结束状态为最后一个命令执行的结果
        结果见：code022_if_一条命令.sh
    2,  取反，形式 ! 命令
        (注意：!和命令之间要用空格隔开)
        如果命令传回值为0，加上!之后传回值为1
        如果命令传回值为非0，加上!之后传回值为0
        同C语言规范：0代表正确，非0代表不正确
        代码见：code023_if_取反.sh
    3,  使用Bash关键字'[['、']]'组成的式子：[[判断式]]
        判断式会传回真假值，传回0为真，传回非0为假
        (注意：[[后面和]]前面都必须要有至少一个空格1)
        代码见：code024_if_Bash关键字.sh
    4,  使用复合命令：((算式))
        这里和常见的不一样：
            如果算式的运算结果不为0，则传回真值(0)
            如果算式的运算结果为0，则传回假值(1)
        ((算式))                运算结果                               判断真假
        ((0))                   0                                      假 
        ((1))                   1                                      真
        ((8))                   8                                      真
        ((-1))                  -1                                     真
        ((2-2))                 0                                      假
        ((5*6))                 30                                     真
    5,  使用内置命令：test判断式
        test是Bash的内置命令，可传回"判断式"的结果，真值传回0，假值传回1
        (注意，test中，>对Bash而言是特殊字符，需要\进行转义)
        代码见：code025_if_test判断式.sh
    6,  使用内置命令；[]
        其形式为：[ 判断式 ]
        []和test的用法是相同的，两者可改写互换
        代码见：code026_if_内置命令[].sh
    7,  使用-a、-o进行逻辑组合：
        用例：
                [ -r filename1 -a -x filename ]
                如果filename1可读且可执行，则为真。-a即"且"之意。
                [ -r filename1 -o -x filename ]
                如果filename1可读且可执行，则为真。-o即"或"之意。
        执行过程如下：
				ubuntu@zxw:temp$ cat test3.sh 
				#!/bin/bash
				if [ -r test1.sh -a -x test2.sh ]; then
				    echo "且True"
				else
				    echo "且False"
				fi
				
				if [ -r test1.sh -o -x test2.sh ]; then
				    echo "或True"
				else
				    echo "或False"
				fi
				
				ubuntu@zxw:temp$ ls
				test1.sh  test2.sh  test3.sh
				ubuntu@zxw:temp$ ./test3.sh 
				且False
				或True
    8,  命令1 && 命令2
        &&称为逻辑的AND，其运作方式是：如果"命令1"执行结果为真，才会执行"命令2";
        如果两个皆为真，则传回真值0，否则传回假值1
        代码见：code027_命令1AND命令2.sh
        &&的特性，经常拿来当做是一种隐形的if语法。例如：
            [ -z "$PS1" ] && return
            这行程序代码的意思是：先判断$PS变量值是否为空，如果是，就执行return命令，
            由子Shell环境返回到父Shell，这等于是结束执行该Script。如果用if语法可改写如下：
            if [ -z "$PS1" ]; then
                return
            fi
        再看一例：
            [ -f /proc/net/if_inet6 ] && echo "这部主机支持IPv6"
            判断/proc/net/if_inet6是否存在，如果存在，就显示主机的核心有支持IPv6协议。
            凡是"[ 判断式 ]　&& 指令"的形式，就视为一种隐形的if-then语法。
    9,  命令1 || 命令2
        ||称为逻辑的OR，其运作方式是：如果"命令1"执行结果为假，才会执行"命令2";
        如果两个之中有一个为真，则传回真值0，否则传回真值1。
        同样，||的特性，也可以当做是一种隐形的if语法。例如：
            prefix="/home"
            defpath="/usr/local/bin"
            [ -z ${prefix:-} ] || prefix=${defpath%/*}
            解释：
                1,  行1，设定$prefix的值为/home
                2,  行2，设定$defpath的值为/usr/local/bin
                3,  行3，因$prefix非空，所以，${prefix:-} 变量扩展的传回值为prefix的变量值(非空)，
                    [ -z ${prefix:-} ]对空值的条件测试失败，其结果为假，根据||的
                    特性，接着执行prefix=${defpath%/*}，它会由$defpath后方删去
                    符合/*的最短字符串，即删去/bin，因此，$prefix的值为/usr/local
            本例可改写成if语法如下：
                prefix="/home"
                defpath="/usr/local/bin"
                if [ ! -z ${prefix:-} ]; then
                    prefix=${defpath%/*}
                fi
    10, &&和||合用
        &&和||合用，可以有if-then-else的效果，例如：
            [ -n ${DEBUG:-} ] && set -v || set +v
            这行程序代码，使用-n测试变量DEBUG是否有设非空值，如果有，表示要进行排错，
            接着执行逻辑AND的下一条指令：set -v；如果无，则不进行排错，而执行
            逻辑OR的下一个指令：set +v，他会把显示程序代码的功能关闭。
            这行程序代码，可以改写成：
                if [ -n "$DEBUG" ]; then
                    set -v
                else
                    set +v
                fi
            以后凡是 "[ 判断式 ] && 指令1 || 指令2"的形式，就视为一种隐形的
                if-then-else的语法。
    11, 注意：
            上述这些条件测试中，[[]]和test，[]的意思和用法是相近的，
            但[[]]比test和[]更自由一点，因为[[]]不必担心某些Bash特殊字符对运算符的影响，
            不必写一堆转义字符。如[[ str<xyz ]]是正确的语法，但在[]中却要写成
            [ str \< xyz ] ，这种陷阱很容易忘记。
            在[[]]中，< > && ||等都可以自由地使用，不必使用转义字符。
        除了[[]]之外，在Bash中，(())也不必理上述提到的特殊字符的影响。
        
        在[[ 判断式 ]]中，如果使用==和!=，且在这两个运算符右边的字符串没有加上单引号
        或双引号，则==和!=会视为想要对比该字符串所形成的"样式",如果相符，则传回0，如果不符，传回1
        代码见：code028_在\[\[\]\]判断式中双等号和不等号.sh
                和 code029_if_加上转义.sh
    12, 自Bash 3.2开始，支持在[[]]中运用新的对比运算符=~。
        =~的右边放置想要的对比样式，
        注意：在=~右方的样式，请勿使用引号含括，否则对比功能无法作用。
    
note29: 条件判断式的真假值
    之前提过，在Bash中什么是真什么是假，是以命令的结束状态是否为0来做判断。
    传回0，即为真；传回非0，即为假。
    在Bash中，这种可以影响程序流程的式子，称为条件判断式。
    判断式的操作数，分为"单元"和"二元"两种。
    “-f 文件名” --- 测试文件是否存在。。。。。单元
    "参数1 -gt 参数2" ---　测试参数1的值是否大于参数2。。。。双元 

note30: 关于文件属性的判断式。
   判断式       在什么情况下为真
    -a 文件     如果文件存在 
    -b 文件     如果文件存在，且该文件是区域设备文件
    -c 文件     如果文件存在，且该文件是字符设备文件
    -d 文件     如果文件存在，且该文件是目录
    -e 文件     如果文件存在 
    -f 文件     如果文件存在，且该文件是一般文件
    -g 文件     如果文件存在，且该文件设立了set group id属性
    -h 文件     如果文件存在，且该文件是符号链接文件
    -k 文件     如果文件存在，且该文件设立了sticky位的属性
    -p 文件     如果文件存在，且该文件是管道文件(FIFO)
    -r 文件     如果文件存在，且该文件具可读取的属性
    -s 文件     如果文件存在，且该文件的文件大小大于0
    -t 文件描述符   如果文件描述符是开启的，且链接了某一个终端
    -u 文件     如果文件存在，且该文件设立了set user id属性
    -w 文件     如果文件存在，且该文件有可写入的属性
    -x 文件     如果文件存在，且该文件有可执行的属性
    -O 文件     如果文件存在，且该文件为有效的使用者 id 所拥有
    -G 文件     如果文件存在，且该文件为有效的群组 id 所拥有
    -L 文件     如果文件存在，且该文件是符号链接文件
    -S 文件     如果文件存在，且该文件是Socket文件
    -N 文件     如果文件存在，且该文件自上次读取后，曾修改过
    文件1 -nt 文件2     如果文件1比文件2新，或文件1存在，文件2不存在
    文件1 -ot 文件2     如果文件1比文件2旧，或文件1不存在，文件2存在
    文件1 -ef 文件2     如果文件1和文件2参考到相同的设备和inode编号

note31: 字符串的条件判断式
    判断式              在什么情况下，为真
    -z 字符串           如果字符串长度为0：空字符串
    -n 字符串           如果字符串长度不为0；非空字符串
    字符串              如果字符串长度不为0：非空字符串
    字符串1 == 字符串2  和　字符串1 = 字符串2　在判断式中一样
    "$name"避免为空，报错
    X"$name"提高可移植性

note32: 算式的条件判断式
    要求：  计算结果是数值(如整数)，非字符串
    判断式              在什么情况下为真
    参数1 -eq 参数2     参数1和参数2的值相等
    参数1 -ne 参数2     参数1和参数2的值不相等
    参数1 -lt 参数2     参数1的值小于参数2的值
    参数1 -le 参数2     参数1的值小于或等于参数2的值
    参数1 -gt 参数2     参数1的值大于参数2的值
    参数1 -ge 参数2     参数1的值大于或等于参数2的值

    
