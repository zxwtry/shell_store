note01: 自定义环境之以一般账户的角色工作时
    Bash Shell的启动配置文件中曾提到Bash Shell的启动配置文件。
    这种机制为用户提供自定义工作环境的弹性。使用者可比较启动配置文件，
    安排方便工作的环境。
    可自定义的配置文件，如下表所示：
        文件名                  时机
        ~/.bash_profile         登录时
        ~/.bashrc               执行新shell时
        ~/.bash_logout          注销时
        (这里的~指的是家目录)
    大多数主机在开设账号后，会自动在用户家目录中建立.bash_profile和.bashrc两个文件。
    而.bash_logout一般默认没有，需由用户自己建立。
    自定义环境的主要目的是要让用户登录主机时，能拥有安全及易于执行命令的环境，项目包括：建立文件的权限、命令搜寻路径、环境变量、命令提示符、别名、喜好的比较器、显示文件使用的颜色等。
    一般在.bash_profile设定可以一体使用的命令、搜寻路径及环境变量，而把其他大部分的设定放在.bashrc。因此.bash_profile文件比较小，.bashrc则比较大。
    建议：自定义.bash_profile时，仍然依循上述惯例，让它越简单越好。
          这样不但好维护，而且不易出错。
    以下是.bash_profile的设定范例
            #设定umask
            umask 022
            #登录后，也执行一个.bashrc
            if [ -f ~/.bashrc ]; then
                . ~/.bashrc
            fi
            #设定自己专用的程序路径
            if [ -d ~/bin ]; then
                PATH=~/bin:$PATH
            fi
            #设定CVS环境
            export CVSROOT=":pserver:zxwtry@192.168.1.2:/home/zxwtry"
            #设定Java环境
            export JAVA_HOME=~/jdk/bin
            export PATH=$PATH:$JAVA_HOME
        行2，设定新建文件、目录的安全权限，分别是644及755(即用666和777各减去022)
    以下是.bashrc的设定范例：
            #判断若不是在互动模式，则不执行.bashrc
            [ -z "$PS1" ] && return
            #设定有颜色的提示
            PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
            #设定方便使用的程序别名
            alias ll='ls -alF'
            alias la='ls -A'
            alias l='ls -CF'
            #如果系统没有启用bash_completion，可在这里启用
            if [ -f /usr/share/bash-completion/bash_completion ]; then
                . /usr/share/bash-completion/bash_completion
            elif [ -f /etc/bash_completion ]; then
                . /etc/bash_completion
            fi
            #重复的命令、ls、bg、fg、exit、ps等指令，不存入历史日志文件中。
            export HISTIGNORE="&:ls:ls *:[bf]g:exit:ps *"
            #设定自己常用的目录，可用cd指令快速切换
            export CDPATH=.:~:~/docs:~/src:~/tmp:/mnt:/usr/src:/usr/lib:/usr/local
    以下是.bash_logout的设定范例
            #注销时，清空tmp目录中的所有内容
            rm -rf ~/tmp/*

note02: 自定义环境---以系统管理员的角色工作时
    系统管理员维护的环境配置文件，主要有3个：
        1,  /etc/profile
        2,  /etc/bash.bashrc
        3,  /etc/skel 目录下所有文件
    前两个文件的用途，在Bash Shell的启动配置文件中已经说明。
    /etc/profile和/etc/bash.bashrc的设定，会影响所有账号的使用环境，因此，要特别小心。
    在/etc/profile中，通常会做如下设定：umask, PATH, 多国语言环境, 提示符号, 别名等等。
    bash.bashrc的内容，大多如下：
        [ -f /etc/profile ] && . /etc/profile
        这表明，当执行交互式的Shell时会检查/etc/profile是否存在，若存在，就执行它。这样的做法，等于是让管理员只要维护一份全局的/etc/profile配置文件即可。
    除了这两个文件，/etc/skel这个目录也很重要。它的作用是，当管理员开设新账户时，账号管理程序会把/etc/skel中的所有文件复制一份放到家目录中，作为用户的环境文件。
    
note03: 数组
    bash数组，其元素的个数没有限制，数组的索引由0开始，但不一定要连续，(可以跳号)。
    索引号也可以用算术表达式表示，如1+2
    bash 3.x只支持一维数组(关系型数组在Bash4.0才支持) 
    用例：
			root@zxwtry:~# A[0]=1
			root@zxwtry:~# A[0]='c'
			root@zxwtry:~# A[0]="good"
			root@zxwtry:~# echo ${A[1]}
			
			root@zxwtry:~# echo ${A[0]}
			good
			root@zxwtry:~# A[3]=1
			root@zxwtry:~# echo ${B[@]}
			
			root@zxwtry:~# echo ${A[@]}
			good 1
			root@zxwtry:~# echo ${A[*]}
			good 1
			root@zxwtry:~# echo ${#A[*]}
			2
			root@zxwtry:~# echo ${#A[@]}
			2
    ${A[@]} --- 一次取出所有的元素：得到以空白隔开的东东
    ${A[*]} --- 一次取出所有的元素：得到一整个字符串
    ${#A[@]} 或者 ${#A[*]} --- 得到数组的元素
    ${#数组[索引]}  --- 如果数组元素是字符串，得到字符串的长度
    unset A --- 取消数组
    unset A[3]  --- 取消某一个元素，取消了第4个元素

note04: Here Document --- 用Here Document设定变量
    bash有一种特殊的程序区域，叫Here Document，也可以用来设定变量。
    Here Document的基本语法：
        命令 <<标记
        ......
        ......
        ......
        标记
    这样会吧命令和标记之间的内容，利用转向输入的方式交给命令去处理。
    标记可以是任何字符串。选用标记的原则：尽量选不常用的字符组合，
        避免该字符串出现在输入的内容中造成bash预判。
    范例如下：
        wc -l <<HERE
        line 1
        line 2
        line 3
        HERE
        (经由wc计算结果得到3行)
    Here Document也支持变量替换。在输入的内容中，如果有变量，bash在转向前会先替换变量值
        From="From: me@example.edu.cn"    
        To="To: you@example.edu.cn"
        Subject="Subject: hello world"
        Msg="吃饭睡觉"
        Em="20161101.txt"
        cat > $Em <<HERE
        $From
        $To
        $Subject
        
        $Msg
        HERE
    执行结果如下：
        root@zxwtry:S005_LinuxShell编程与服务器管理# chmod +x code011_Here_Document_变量替换.sh 
        root@zxwtry:S005_LinuxShell编程与服务器管理# ./code011_Here_Document_变量替换.sh 
        root@zxwtry:S005_LinuxShell编程与服务器管理# cat 20161101.txt 
        From: me@example.edu.cn
        To: you@example.edu.cn
        Subject: hello world
        
        吃饭睡觉
    Here Document的变量设定
        WOW="WOW, great!"
        var=$(cat <<HERE
        Line 1 is good
        They are tencent, alibaba and baidu.
        $WOW
        HERE)
        echo $var
    执行结果如下：
        root@zxwtry:S005_LinuxShell编程与服务器管理# ./code012_Here_Document_变量设定.sh 
        ./code012_Here_Document_变量设定.sh: line 12: warning: here-document at line 8 delimited by end-of-file (wanted `HERE')
        Line 1 is good They are tencent, alibaba and baidu. WOW, great!
    替换$WOW的变量值之后转向输出，交给cat显示出来，其结果放置在$()中进行替换变量，得到上述结果。
    在标记加上双引号也是可以的，例如上例写成$(cat <<"HERE")，表示这个Here Document拥有和双引号一样的特性，即支持变量替换的功能。

note05: Here Document   --- 控制Here Document的格式
    Here Document支持两种控制输出格式的做法：
    1,  关闭变量替换的功能
        有时候，希望按照原本的样子转向输出，不做任何变量替换。做法如下：
            cat <<'HERE'
            Line 1 is good
            They are tencent, alibaba, and baidu.
            $WOW
            HERE
        行1中，对标记HERE加上单引号，即可关闭变量替换。
        执行结果：
            Line 1 is good
            They are tencent, alibaba, and baidu.
            $WOW
        $WOW还是保持原样，不做变量替换。
    2,  去掉每行之前的TAB字符：
            cat <<-'HERE'
                Line 1 is good.
                They are tencent, alibaba, and baidu.
                $WOW
            HERE
        行2~4每行前面都有一个TAB字符。行1在标记前加上-，表示要抑制各行首TAB的作用，输出结果同前例。

note06: Here Document   --- 利用Here Document做多行批注
    用例：
        : <<DO-NOTTHING
        这是第一行批注
        这是第二行批注
        这是第三行批注
        这是第四行批注
        DO-NOTTHING
        :代表"什么都不做"的空命令。这个区域在script中，bash会忽略不执行，因此，达到批注的效果。

note07: Here Document   --- 利用Here Document，打包C(或其他程序语言)的原始码
    这是Cracker散步安全漏洞时，最喜欢的用法。举例如下：
    代码在：code013_Here_Document_打包C的原始码.sh    
			#!/bin/bash
			echo "正在产生 hello.c...."
			echo
			cat <<'EOF' > hello.c
			#include <stdio.h>
			int main(){
			    printf("hello world!\n");
			    return 0;
			}
			EOF
			echo "编译hello.c..."
			echo
			#编译hello.c，产生执行文件
			gcc -o hello hello.c
			#若编译成功，就执行
			if [ $? -eq 0 ]; then
			    echo "执行hello..."
			    echo
			    ./hello
			else
			    echo 'Compile ERROR: hello.c'
			fi
    执行结果如下：
			root@zxwtry:S005_LinuxShell编程与服务器管理# ./code013_Here_Document_打包C的原始码.sh 
			正在产生 hello.c....
			
			编译hello.c...
			
			执行hello...
			
			hello world!
    这个script利用Here Document，夹带了一个hello.c程序的原始码，执行本script时会产生hello.c，
        接着利用gcc编译hello.c，若编译无误，就执行程序文件hello
    这就是shell script携带攻击程序的原型。

note08: 高级变量
    高级变量，有3个主题：
        1,  变量扩展
        2,  命令替换
        3,  算术扩展
    ${变量名称}     ---     变量替换    ---     ${filename}
    $(命令)         ---     命令替换    ---     $(ls /)
    $((算术式))     ---     算术扩展    ---     $((9+9))

note09: 变量扩展：测试存在性及空值
    基本型：${变量名称} 
    "变量存在"的定义：   如果变量曾设值过，则称该变量存在；反之，不曾设值过，或曾用unset取消变量，
                        则称变量不存在或未定义
    变量设值有两种情况： 1,  其值"非空"      name='zxwtry'   name非空
                        2,  其值为"空"      name=           name为空，以null表示
    测试变量"存在与否"的基本用法：
        语法：${待测变量-默认值}
        判断条件：如果变量存在，传回变量的值；不存在，传回默认值。
    执行过程如下：
			root@zxwtry:shell# name="zxwtry"
			root@zxwtry:shell# echo ${name-"default"}
			zxwtry
			root@zxwtry:shell# unset name
			root@zxwtry:shell# echo ${name-"default"}
			default
    在script的运用中，通常将不存在和空值视为同一类的情况。
