note01: 自定义环境之以一般账户的角色工作时
    Bash Shell的启动配置文件中曾提到Bash Shell的启动配置文件。
    这种机制为用户提供自定义工作环境的弹性。使用者可比较启动配置文件，
    安排方便工作的环境。
    可自定义的配置文件，如下表所示：
        文件名                  时机
        ~/.bash_profile         登录时
        ~/.bashrc               执行新shell时
        ~/.bash_logout          注销时
        (这里的~指的是家目录)
    大多数主机在开设账号后，会自动在用户家目录中建立.bash_profile和.bashrc两个文件。
    而.bash_logout一般默认没有，需由用户自己建立。
    自定义环境的主要目的是要让用户登录主机时，能拥有安全及易于执行命令的环境，项目包括：建立文件的权限、命令搜寻路径、环境变量、命令提示符、别名、喜好的比较器、显示文件使用的颜色等。
    一般在.bash_profile设定可以一体使用的命令、搜寻路径及环境变量，而把其他大部分的设定放在.bashrc。因此.bash_profile文件比较小，.bashrc则比较大。
    建议：自定义.bash_profile时，仍然依循上述惯例，让它越简单越好。
          这样不但好维护，而且不易出错。
    以下是.bash_profile的设定范例
            #设定umask
            umask 022
            #登录后，也执行一个.bashrc
            if [ -f ~/.bashrc ]; then
                . ~/.bashrc
            fi
            #设定自己专用的程序路径
            if [ -d ~/bin ]; then
                PATH=~/bin:$PATH
            fi
            #设定CVS环境
            export CVSROOT=":pserver:zxwtry@192.168.1.2:/home/zxwtry"
            #设定Java环境
            export JAVA_HOME=~/jdk/bin
            export PATH=$PATH:$JAVA_HOME
        行2，设定新建文件、目录的安全权限，分别是644及755(即用666和777各减去022)
    以下是.bashrc的设定范例：
            #判断若不是在互动模式，则不执行.bashrc
            [ -z "$PS1" ] && return
            #设定有颜色的提示
            PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
            #设定方便使用的程序别名
            alias ll='ls -alF'
            alias la='ls -A'
            alias l='ls -CF'
            #如果系统没有启用bash_completion，可在这里启用
            if [ -f /usr/share/bash-completion/bash_completion ]; then
                . /usr/share/bash-completion/bash_completion
            elif [ -f /etc/bash_completion ]; then
                . /etc/bash_completion
            fi
            #重复的命令、ls、bg、fg、exit、ps等指令，不存入历史日志文件中。
            export HISTIGNORE="&:ls:ls *:[bf]g:exit:ps *"
            #设定自己常用的目录，可用cd指令快速切换
            export CDPATH=.:~:~/docs:~/src:~/tmp:/mnt:/usr/src:/usr/lib:/usr/local
    以下是.bash_logout的设定范例
            #注销时，清空tmp目录中的所有内容
            rm -rf ~/tmp/*

note02: 自定义环境---以系统管理员的角色工作时
    系统管理员维护的环境配置文件，主要有3个：
        1,  /etc/profile
        2,  /etc/bash.bashrc
        3,  /etc/skel 目录下所有文件
    前两个文件的用途，在Bash Shell的启动配置文件中已经说明。
    /etc/profile和/etc/bash.bashrc的设定，会影响所有账号的使用环境，因此，要特别小心。
    在/etc/profile中，通常会做如下设定：umask, PATH, 多国语言环境, 提示符号, 别名等等。
    bash.bashrc的内容，大多如下：
        [ -f /etc/profile ] && . /etc/profile
        这表明，当执行交互式的Shell时会检查/etc/profile是否存在，若存在，就执行它。这样的做法，等于是让管理员只要维护一份全局的/etc/profile配置文件即可。
    除了这两个文件，/etc/skel这个目录也很重要。它的作用是，当管理员开设新账户时，账号管理程序会把/etc/skel中的所有文件复制一份放到家目录中，作为用户的环境文件。
    
note03: 数组
    bash数组，其元素的个数没有限制，数组的索引由0开始，但不一定要连续，(可以跳号)。
    索引号也可以用算术表达式表示，如1+2
    bash 3.x只支持一维数组(关系型数组在Bash4.0才支持) 
    用例：
            root@zxwtry:~# A[0]=1
            root@zxwtry:~# A[0]='c'
            root@zxwtry:~# A[0]="good"
            root@zxwtry:~# echo ${A[1]}
            
            root@zxwtry:~# echo ${A[0]}
            good
            root@zxwtry:~# A[3]=1
            root@zxwtry:~# echo ${B[@]}
            
            root@zxwtry:~# echo ${A[@]}
            good 1
            root@zxwtry:~# echo ${A[*]}
            good 1
            root@zxwtry:~# echo ${#A[*]}
            2
            root@zxwtry:~# echo ${#A[@]}
            2
    ${A[@]} --- 一次取出所有的元素：得到以空白隔开的东东
    ${A[*]} --- 一次取出所有的元素：得到一整个字符串
    ${#A[@]} 或者 ${#A[*]} --- 得到数组的元素
    ${#数组[索引]}  --- 如果数组元素是字符串，得到字符串的长度
    unset A --- 取消数组
    unset A[3]  --- 取消某一个元素，取消了第4个元素

note04: Here Document --- 用Here Document设定变量
    bash有一种特殊的程序区域，叫Here Document，也可以用来设定变量。
    Here Document的基本语法：
        命令 <<标记
        ......
        ......
        ......
        标记
    这样会吧命令和标记之间的内容，利用转向输入的方式交给命令去处理。
    标记可以是任何字符串。选用标记的原则：尽量选不常用的字符组合，
        避免该字符串出现在输入的内容中造成bash预判。
    范例如下：
        wc -l <<HERE
        line 1
        line 2
        line 3
        HERE
        (经由wc计算结果得到3行)
    Here Document也支持变量替换。在输入的内容中，如果有变量，bash在转向前会先替换变量值
        From="From: me@example.edu.cn"    
        To="To: you@example.edu.cn"
        Subject="Subject: hello world"
        Msg="吃饭睡觉"
        Em="20161101.txt"
        cat > $Em <<HERE
        $From
        $To
        $Subject
        
        $Msg
        HERE
    执行结果如下：
        root@zxwtry:S005_LinuxShell编程与服务器管理# chmod +x code011_Here_Document_变量替换.sh 
        root@zxwtry:S005_LinuxShell编程与服务器管理# ./code011_Here_Document_变量替换.sh 
        root@zxwtry:S005_LinuxShell编程与服务器管理# cat 20161101.txt 
        From: me@example.edu.cn
        To: you@example.edu.cn
        Subject: hello world
        
        吃饭睡觉
    Here Document的变量设定
        WOW="WOW, great!"
        var=$(cat <<HERE
        Line 1 is good
        They are tencent, alibaba and baidu.
        $WOW
        HERE)
        echo $var
    执行结果如下：
        root@zxwtry:S005_LinuxShell编程与服务器管理# ./code012_Here_Document_变量设定.sh 
        ./code012_Here_Document_变量设定.sh: line 12: warning: here-document at line 8 delimited by end-of-file (wanted `HERE')
        Line 1 is good They are tencent, alibaba and baidu. WOW, great!
    替换$WOW的变量值之后转向输出，交给cat显示出来，其结果放置在$()中进行替换变量，得到上述结果。
    在标记加上双引号也是可以的，例如上例写成$(cat <<"HERE")，表示这个Here Document拥有和双引号一样的特性，即支持变量替换的功能。

note05: Here Document   --- 控制Here Document的格式
    Here Document支持两种控制输出格式的做法：
    1,  关闭变量替换的功能
        有时候，希望按照原本的样子转向输出，不做任何变量替换。做法如下：
            cat <<'HERE'
            Line 1 is good
            They are tencent, alibaba, and baidu.
            $WOW
            HERE
        行1中，对标记HERE加上单引号，即可关闭变量替换。
        执行结果：
            Line 1 is good
            They are tencent, alibaba, and baidu.
            $WOW
        $WOW还是保持原样，不做变量替换。
    2,  去掉每行之前的TAB字符：
            cat <<-'HERE'
                Line 1 is good.
                They are tencent, alibaba, and baidu.
                $WOW
            HERE
        行2~4每行前面都有一个TAB字符。行1在标记前加上-，表示要抑制各行首TAB的作用，输出结果同前例。

note06: Here Document   --- 利用Here Document做多行批注
    用例：
        : <<DO-NOTTHING
        这是第一行批注
        这是第二行批注
        这是第三行批注
        这是第四行批注
        DO-NOTTHING
        :代表"什么都不做"的空命令。这个区域在script中，bash会忽略不执行，因此，达到批注的效果。

note07: Here Document   --- 利用Here Document，打包C(或其他程序语言)的原始码
    这是Cracker散步安全漏洞时，最喜欢的用法。举例如下：
    代码在：code013_Here_Document_打包C的原始码.sh    
            #!/bin/bash
            echo "正在产生 hello.c...."
            echo
            cat <<'EOF' > hello.c
            #include <stdio.h>
            int main(){
                printf("hello world!\n");
                return 0;
            }
            EOF
            echo "编译hello.c..."
            echo
            #编译hello.c，产生执行文件
            gcc -o hello hello.c
            #若编译成功，就执行
            if [ $? -eq 0 ]; then
                echo "执行hello..."
                echo
                ./hello
            else
                echo 'Compile ERROR: hello.c'
            fi
    执行结果如下：
            root@zxwtry:S005_LinuxShell编程与服务器管理# ./code013_Here_Document_打包C的原始码.sh 
            正在产生 hello.c....
            
            编译hello.c...
            
            执行hello...
            
            hello world!
    这个script利用Here Document，夹带了一个hello.c程序的原始码，执行本script时会产生hello.c，
        接着利用gcc编译hello.c，若编译无误，就执行程序文件hello
    这就是shell script携带攻击程序的原型。

note08: 高级变量
    高级变量，有3个主题：
        1,  变量扩展
        2,  命令替换
        3,  算术扩展
    ${变量名称}     ---     变量替换    ---     ${filename}
    $(命令)         ---     命令替换    ---     $(ls /)
    $((算术式))     ---     算术扩展    ---     $((9+9))

note09: 变量扩展：测试存在性及空值
    1,  基本型：${变量名称} 
        "变量存在"的定义：   如果变量曾设值过，则称该变量存在；反之，不曾设值过，或曾用unset取消变量，
                            则称变量不存在或未定义
        变量设值有两种情况： 1,  其值"非空"      name='zxwtry'   name非空
                            2,  其值为"空"      name=           name为空，以null表示
    2,  测试变量"存在与否"的基本用法：
            语法：${待测变量-默认值}
            判断条件：如果变量存在，传回变量的值；不存在，传回默认值。
        执行过程如下：
                root@zxwtry:shell# name="zxwtry"
                root@zxwtry:shell# echo ${name-"default"}
                zxwtry
                root@zxwtry:shell# unset name
                root@zxwtry:shell# echo ${name-"default"}
                default
        在script的运用中，通常将不存在和空值视为同一类的情况。
    3,  测试变量"不存在"或其值为空："传回"一个默认值：
        语法：  ${待测变量:-默认值}
        判断条件：  如果变量不存在或其值为空，则符合判断，传回默认值作为判断
        用例：  myname=
                r=${myname:-'zxwtry'}
                echo $r
    4,  -和:-的区别：
        *   如果变量扩展的条件式中只有-这个符号，则只做变量"存在性"的判断
        *   如果变量扩展的条件式中有:-这个符号，除了判断变量"存在性"之外，多加一个变量是否存在。
    5,  拆解条件表达式：
        上述变量扩展式${变量:-默认值}，可以使用if-then-else的语法来拆解
        if [ 变量不存在 或 空值 ]; then
            传回 "默认值"
        else
            传回 "变量值"
        fi
    6,  条件式的用途
        变量扩展式${变量名称:-默认值}的主要用途是：在script周姑娘，这个变量一定要有值才行。
        因此，变量扩展的结果，一定要传回一个非空值(使用默认值或变量值)
        用例：(一定要有信件文件名)
            MSG=${filename:-"testmsg.txt"}
            cat > $MSG <<HERE
            From: im@example.edu.cn
            To: yr@example.edu.cn
            Subject: 测试一下
            这是一封测试信，请勿回复！ 
            HERE
    7,  特殊运用法
        [ -n ${DEBUG:-} ] && set -v
        [ ]是测试条件的语法。
        其中，  -n是用来测试后接的变量是否有值(测：不空)。如果非空，传回真值。
                ${DEBUG:-}就是-n要测试的对象。:-的后面本应该放置默认值的地方，没有任何东西，表示故意要默认值为空值。
        这样做的目的是：
            如果变量DEBUG非空值，那么[-n]条件测试就会成立，接着执行逻辑AND即(&&)的下一个指令：set -v，于是script就进入了查错模式；
            如果变量DEBUG没有设定或其值为空，则变量扩展的结果为空值，[-n]条件测试就会不成立，接着逻辑AND即(&&)的下一个指令不再执行，查错的功能没有打开。
            这样，切换script的查错模式就非常方便。如果要排错，就给DEBUG设一个值；否则就是正常的模式。
    8,  测试变量“不存在”或其值为空：给变量设一个默认值
        语法：${待测变量:=默认值}
        用例：  unset count
                r=${count:=100}
                echo $count
                echo $r
                //输出100 100
        用例：  count=500
                r=${count:=100}
                echo $count
                echo $r
                //输出500 500
    9,  测试变量是否"不存在"或其值为空：提示错误信息
        语法：  ${待测变量:?提示信息} 
        可以表示成拆解条件表达式
            if [ 变量不存在 或 空值 ]; then
                显示变量名称:'提示信息'
                exit
            else
                继续执行script的下一个指令
            fi
        条件式的用途:
            目的：确保某变量值一定要存在。
            如果该变量的值为空值，就显示预先准备好的错误信息，接着结束script，不再执行下去。
    11, 测试变量的"存在性"  
        语法：  ${待测变量:+真值}
        释义：  若变量存在且其值非空，则传回"真值"；若不然，传回空值
        (这里的真值，只要是非空字符串或数字都可以)
        用例：  Fighting="Coding More Code."
                r=${Fighting:+"true"}
                echo $r
                #最后输出true
        用途：  测试某件事是真的
                例如，上例中，Fighting存在，所以传回true，表示此事为真
                fgrep.sh文件内容如下：
                    #!/bin/bash
                    exec grep -F ${1+"$@"}
                说明：
                    这里使用exec执行grep程序，-F表示使用一串固定的字符串(可用换行字符分开)，作为寻找的样式。
                    其中，  ${1+"$@"}的意思是：若$1存在(指定要寻找的关键词)，则传回所有的参数。
                            $@表示fgrep.sh一次可以搜索多个文件。
                用法：
                    ./fgrep.sh Mem /proc/meminfo /root/test.txt
                由于$1=Mem非空，判断成立，因此，${1+"$@"}传回$@，此变量的值等于所有的位置参数组合起来：
                    "Mem /proc/meminfo /root/test.txt"，因此，最后exec执行的指令是：
                    grep -F Mem /proc/meminfo /root/test.txt
                    这表示，grep可由后面的两个文件去寻找关键字Mem
    12, 整理如下：
        :       空          测空值
        -       负向        测不存在
        =       设值        给空值变量设一个默认值
        ?       有问题      检查条件是否完备再来执行
        +       正向        测试存在

note10: 变量扩展：取字符串切片
    字符串编号，从0开始。
    语法一：    ${变量:位置起点}
                由指定位置开始，截取子字符串到字符串结束
                用例：
                    s="abcdefg"
                    subs=${s:1}
                    echo $subs
                执行结果是：bcdefg
    语法二：    ${变量:位置起点:长度}
    补充：      命令行参数
                例如：./test.sh x y z这指令中：
                $0:   ./test.sh
                $1:   x
                $2:   y
                $3:   z
    语法三：    ${@:起点} 
                由起点开始，取得后面所有的位置参数
                poz.sh内容如下：
                    #!/bin/bash
                    #显示命令本身
                    echo $0
                    echo ${$:1}
    语法四：    ${@:起点:个数}
                poz.sh内容如下：
                    #!/bin/bash
                    echo ${@:2:2}
                ./poz.sh 11 22 33 44
                显示22 33

note11: 变量扩展：取得字符串长度
    语法：  ${#变量名称}
            传回变量值的字符串长度
    语法：  expr length "字符串"
            用例：  str="Here you are"
                    len=$(expr length "$str")
                    echo "str字符串长度是：$len"
    语法：  expr "字符串":'.*'
            :后接的.*是一个任意多个字符的字符串样式，expr会根据此样式来对比"字符串"，等于是计算字符串的长度
            用例：  str="Here you are"
                    len=$(expr "$str":'.*')
                    echo "str字符串长度是：$len"
    比较：
            ${#变量名称}    计算字符串长度
            ${#数组[@]}     取得数组元素个数
            ${#数组[*]}     取得数组元素个数
   
note12: 变量扩展：对比样式---由字符串前面对比，删除相符者
    语法：  ${变量#样式}
            释义：由前面(最左边)开始，对比变量值，删除"最短相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename#/*/}
                    echo $r
                    显示结果：sbin/ntpdate
            用例：
                    filename="//usr/sbin/ntpdate"
                    r=${filename#/*/}
                    echo $r
                    显示结果：usr/sbin/ntpdate

    语法:   ${变量##样式}
            释义：由前面(最左边)开始，对比变量值，删除"最长相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename##/*/}
                    echo $r
                    显示结果：ntpdate

note13: 变量扩展：对比样式---由字符串后面对比，删除相符者
    语法：  ${变量%样式}
            释义：由后面(最右边)开始，对比变量值，删除"最短相符合的字符串"
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename%/*/}
                    echo $r
                    显示结果：/usr/sbin/ntpdate
            用例：
                    filename="/usr/sbin/ntpdate"
                    r=${filename%/*}
                    echo $r
                    显示结果：/usr/sbin

    语法:   ${变量##样式}
            释义：由后面(最右边)开始，对比变量值，删除"最长相符合的字符串"
            用例：
                    example="www.example.edu.cn"
                    m=${example%%.*}
                    echo $m
                    输出结果：www

note14: 变量扩展：对比样式---取代或删除部分字符串
    语法：  ${变量/样式/替换字符串}     ---值替换第一个
    释义：  若变量中，有符合样式的字符串(取最长的)，则使用替换字符串予以取代
            用例：
                    act="mail:x:8:"
                    r=${act/:/,}
                    echo $r
                    输出：mail,x:8:
    语法：  ${变量//样式/替换字符串}     ---值替换全部
    释义：  若变量中，有符合样式的字符串(取最长的)，则使用替换字符串予以取代
            用例：
                    act="mail:x:8:"
                    r=${act//:/,}
                    echo $r
                    输出：mail,x,8,

note15: 变量扩展：对比样式---把对比符合的字符串删除
    语法：  ${变量/样式/}
    释义：  删除第一个符合样式的字符串，只删一个
            用例：
                    act="mail:x:8:8:mail:/var/mail:/bin/sh"
                    r=${act/:/}
                    echo $r
                    执行结果：第一个:删除后的样子。
                    mailx:8:8:mail:/var/mail:/bin/sh
    语法：  ${变量//样式/}
    释义：  删除所有符合样式的字符串，全部删除
            用例：
                    act="mail:x:8:8:mail:/var/mail:/bin/sh"
                    r=${act/:/}
                    echo $r
                    执行结果：所有:删除后的样子。
                    mailx88mail/var/mail/bin/sh

note16: 变量扩展：对比样式---要求样式在句首或句尾
    在对比样式时，若在样式前加上#，如#T，则该样式要出现在变量值的开头才算符合。
            用例：
                    str="Yes, This is a Title."
                    r=${str/#T* /}
                    echo $r
                    执行结果：Yes, This is a Title.
            用例：
                    str="Yes, This is a Title."
                    r=${str/T* /}
                    echo $r
                    执行结果：Yes, Title.
            用例：
                    str="Tony , This is Joy."
                    r=${str/#T* /}
                    echo $r
                    执行结果：Joy.

note17: 变量扩展：对比样式---小整理
        语法                        用途
    1,  ${变量/样式/替换字符串}     替换第一个对比符合的字符串
    2,  ${变量//样式/替换字符串}    替换全部对比符合的字符串
    3,  ${变量/#样式/替换字符串}    替换第一个对比符合的字符串，由变量值开头对比
    4,  ${变量/%样式/替换字符串}    替换第一个对比符合的字符串，由变量值尾部对比
    5,  ${变量/样式/}               删除第一个对比符合的字符串
    6,  ${变量//样式/}              删除所有对比符合的字符串
    7,  ${变量/#样式/}              删除第一个对比符合的字符串，由变量值开头对比
    8,  ${变量/%样式/}              删除第一个对比符合的字符串，由变量值尾部对比

note18: 变量扩展：取变量名称列表、数组索引列表
    取变量名称列表：
        语法：  ${!开头字符串@} 或 ${!开头字符串*}
        释义：  把所有以指定字符串开头的变量名称列出，各变量之间，用$IFS定义的
                第一个分隔字符(通常是空格符)隔开。
        用例：  
                filename="ntpdate"
                dir="/usr/sbin"
                dir_file="$dir/$filename"
                echo ${!di@}
                执行结果：dir dir_file
    取数组索引列表：
        语法：  ${!数组变量[@]} 或 ${!数组变量[*]}
        释义：  把数组变量所有的索引列出，各索引值之间，用$IFS定义的第一个分隔字符
                (通常是空格符)隔开。
        用例：
                ar=(a b c xy z)
                r=${!ar[@]}
                echo $r
                执行结果：0 1 2 3 4
    注意：
        1,  取数组索引列表，只有在Bash 3以后的版本才支持，Bash 2没有。
        2,  如果扩展式使用@符号，并且出现在双引号中，如，${!数组变量[@]}，
            则其传回的不是一个字符串，而是将索引值各视为单独的字符串。
            用例：
                    ar=(a b c xy z)
                    for i in "${!ar[@]}"
                    do
                        echo "index $i: ${ar[Si]}"
                    done
                    执行结果：
                    index 0: a
                    index 1: b
                    index 2: c
                    index 3: xy
                    index 4: z
    
note19: 命令替换
    释义：  把命令执行后的标准输出放入变量中。
    举例：  想查看工作目录中所有的文件名，可执行ls命令。
            如何把这些文件名存入变量中，供往后的程序代码再利用？
            使用命令替换。
    语法：  
            新式的写法：    变量名称=$(命令) 
            旧式的写法：    变量名称=`命令`
    说明：  
            Bash会把执行命令后产生的标准输出，赋值给指定的变量。
            在这个过程中，默认会自动删除换行字符。
            (举例中的问题，只需要执行： dirs=$(ls))
    用例：
            dirs=$(ls)
            for f in $dirs
            do
                echo $f
            done
    用例：
            file="/home/zxwtry/.bash/id_rsa"
            IFS=' '
            fc=$(cat $file)
            echo $fc
            (由于IFS改用空格符，变量扩展时，换行字符不会删除，
            这样才能保持该文件的内容。。。如果不改设FIS，则
            passwd的每行会去掉换行字符，变成一个以空格符隔开
            各行的字符串。)
            (行3若改成fc=$(<$file)，效果是一样的。这是使用
            转向输入取得文件内容，再扩展成变量内容放入fc中。)
            (在变量替换中，可以包含两个或两个以上的指令，
            如，可取得上层目录的名称：PDIR=$(cd ..;pwd)
            这里有两道指令；cd ..和pwd，中间用;隔开，命令替换
            的值是最后一道指令执行的结果。)
            (在命令替换里面，也可以包含其他命令替换。例如：
            r=$(du -s $(pwd))可取得工作目录占用磁盘用量的总和。)
    用例：
            #!/bin/bash
            tmp=$(ifconfig | grep 'inet addr')
            r=${tmp/inet addr:/}
            ip=${r/ Bcast*/}
            echo $ip
            执行结果：输出：ip

note20: 算术扩展
    用例：
            执行如下片段：
                I=8+16
                echo $I
            执行结果：输出8+16
    语法：  算术扩展的语法：    $((算术式))
    用例：  
            I=$((8+16))
            echo $I
            执行结果：输出24
            I=$(8+16)
            执行出错，8+16: command not found

note21: 算术运算---之前提到的算术扩展
    名称            语法            范例
    算术扩展        $((算术符))     r=$((2+5*8))
    使用外部命令    expr算术式      r=`expr 4+5`
    expr            
    使用$[]         $[算术式]       r=$[4+5]
    使用内置命令    declare -i 变量=算术式
    declare         declare -i r=8+16
    使用内置命令    let 算术式      let r=8+16
    let

note22: 算术运算---简介
    1,  算术式由运算符和操作数，扩展式会先展开
        用例：  
                echo $((${j:-8}+2))
                如果j不存在或为空，输出10
                如果j存在且是数字，输出j+2
                如果j存在且是字符串形式，输出2
                如果j存在且是1.23小数形式，运行出错。
                (具体见代码：code019_算术运算_简介.sh)
    2,  在求值时，如果算术式中变量不存在或者为空值，该变量值为0
        用例：
                echo $((k+4))
                执行结果：输出：4
    3,  如果数字以0开头，则视为八进制数字。
        用例：
                016等于十进制数14
    4,  以0x或0X开头，视为16进制数字。
        用例：
                0x2a等于十进制的42
    5,  不同进制的数字，可使用"基底#数字"的表示法，其中基底范围为2~64。
        如果数字超过9，则以a代表10，以b代表11，依次类推。
        用例：
                十五进制数15#1b，其值为：1*15+11=26。
                二进制数2#1010，其值为：1*8+0*4+1*2+0*1=10。
    6,  Bash运算符的优先级表：
        优先级      运算符
        1           i++　   i--
        2           ++i     --i
        3           -负号   +正号
        4           !逻辑'非'   ~位取反
        5           **乘方
        6           *乘  /除  %取余
        7           +加  -减
        8           <<位向左移   >>
        9           <=  >=  >  < 
        10          ==   !=
        11          & 位的AND
        12          ^ 位的互斥？？？？？？？
        13          | 位的OR
        14          && 逻辑的AND
        15          || 逻辑的OR
        16          '?:'三目运算符
        17          = *= /= %= += -= <<= >>= &= ^= |=
        18          '式子1，式子2'逗号运算
        (小括号可改变运算的优先级)

note23: 算术扩展的补充：
    算术扩展的语法：    $((表达式))
    如果表达式中有变量，该变量名称之前最好不要加上$这个符号，
    用来避免该变量不存在造成语法的错误。
    用例：
            unset i
            echo $((12+$i))
            运行结果：  语法错误
    用例：
            unset i
            echo $((12+i))
            运行结果：  12
    小结：
            $((12+i))           正确范例
            $((12+$i))          当i不存在时，语法错误，不建议使用
            $((12+${i}))        当i不存在时，语法错误，不建议使用
            $((12+${j:-8}))     表达式中有"变量扩展"的正确范例

note24: 使用外部程序expr做算术运算
    外部程序expr本来的作用，是在"标准输出"显示表达式的值
    语法：
            expr 3+2
            输出结果：  3+2
            expr 3 + 2
            输出结果：  5
    特点：
            如果注重跨平台、可移植，在Script程序的开发中可使用expr替代其他算术运算。
    注意：
            注意，"表达式"中是否含有bash shell的特殊字符，例如*、|、<、>、!、&、(、)等。如果有的话，要用\进行转义。
    语法：
            r=`expr 参数1 \| 参数2`
            (|代表或。如果"参数1"存在，非空，不是0，则传回"参数1"的值；、
            否则，传回"参数2"的值。)
            用例：
                    r=`expr 3 \| 0`
                    echo $r
                    执行结果：  输出3
            用例：
                    r=`expr 0 \| 2`
                    echo $r
                    执行结果：  输出2
    语法：
            r=`expr 参数1 \& 参数2`
            如果"参数1"和"参数2"皆存在、非空、不是0，则传回"参数1"的值，否则传回0
            用例：
                    r=`expr 3 \& 0`
                    echo $r
                    执行结果：  输出0
    比较：
            算式                        比较式是否成立      r值
            r=`expr 1 \< 2`             是                  1
            r=`expr 3 \<= 2`            否                  0
            r=`expr 2 == 2`             是                  1
            r=`expr 3 \!= 2`            是                  1
            r=`expr 3 \>= 2`            是                  1
            r=`expr 3 \> 2`             是                  1
    加：
            r=`expr 4 + 5`
            echo $r
            执行结果：  输出9
            r=`expr 4+5`
            echo $r
            执行结果：  输出4+5
    乘：
            需要 \*
    除：
            /
    乘方：
            expr没有乘幂功能，`expr 2**3`是错误的。

note25: 使用$[]做算术运算
    与$(())类似
    用例：
            r=$[4+5]
            echo $r
            执行结果：  输出9
    用例：
            r=$[2**3]
            echo $r
            执行结果：  输出8


note26: 使用内置命令declare、let作算术运算
    用例：
            declare -i I
            I=8+16
            echo $I
            执行结果：  输出24
            (表示，使用declare将I设置成整数，保存的不再是字符串)
    特点：
            1,  运算符和操作数之间，不能有空格符，而要紧密连接
            2,  特殊符号不必使用\转义，例如乘法*，乘方**
            3,  算式中，可包含其他变量，变量之前不必加上$
    用例；
            declare -i I
            I=8+16
            I=16-8
            I=5*3
            I=22/5
            I=2**3
            I=100%43
            declare -i J
            J=I+1
    特点：
            1,  let在算术运算的用法，基本和declare类似 
            2,  可以使用空格符，让表达式可读性更高，但必须使用引号才行：
                let "i = i + 5"
                let "n = i <20 ? 1 : 0"

note27: 流程控制---命令的结束状态
    1， Bash Shell中，流程控制命令有两大类："选择"和"循环"
    2,  "选择"的有：if 、case、select
    3,  "循环"的有：for、while、until、select
    4,  每一个命令执行后，都会传回一个结束状态值。
        成功：返回0
    
note28: 流程控制---if 
    1,  if-then-else
        if 条件测试; then
            命令区域
        fi
            用例：
                if (( 2 < 10 )); then
                    echo "真"  
                fi
            用例：
                if (( 2 < 10 )); then echo "真"; fi
    2,  if-then-else
        if 条件测试; then
            命令区域
        else
            命令区域2
        fi
    3,  if-then-elif-else
        if 条件测试1; then
            命令区域1
        elif 条件测试2; then
            命令区域2
        else
            命令区域3
        fi
    4,  (())是Bash的复合命令，内置算式
        可以使用let ""代替
        见code21_if_let.sh和code21_if_双括号.sh

note28: 条件测试的写法
    1,  执行某一个命令的结果：
        这里的命令，可包括管道命令，例如：命令1 | 命令2 | 命令3
        其结束状态为最后一个命令执行的结果
        结果见：code022_if_一条命令.sh
    2,  取反，形式 ! 命令
        (注意：!和命令之间要用空格隔开)
        如果命令传回值为0，加上!之后传回值为1
        如果命令传回值为非0，加上!之后传回值为0
        同C语言规范：0代表正确，非0代表不正确
        代码见：code023_if_取反.sh
    3,  使用Bash关键字'[['、']]'组成的式子：[[判断式]]
        判断式会传回真假值，传回0为真，传回非0为假
        (注意：[[后面和]]前面都必须要有至少一个空格1)
        代码见：code024_if_Bash关键字.sh
    4,  使用复合命令：((算式))
        这里和常见的不一样：
            如果算式的运算结果不为0，则传回真值(0)
            如果算式的运算结果为0，则传回假值(1)
        ((算式))                运算结果                               判断真假
        ((0))                   0                                      假 
        ((1))                   1                                      真
        ((8))                   8                                      真
        ((-1))                  -1                                     真
        ((2-2))                 0                                      假
        ((5*6))                 30                                     真
    5,  使用内置命令：test判断式
        test是Bash的内置命令，可传回"判断式"的结果，真值传回0，假值传回1
        (注意，test中，>对Bash而言是特殊字符，需要\进行转义)
        代码见：code025_if_test判断式.sh
    6,  使用内置命令；[]
        其形式为：[ 判断式 ]
        []和test的用法是相同的，两者可改写互换
        代码见：code026_if_内置命令[].sh
    7,  使用-a、-o进行逻辑组合：
        用例：
                [ -r filename1 -a -x filename ]
                如果filename1可读且可执行，则为真。-a即"且"之意。
                [ -r filename1 -o -x filename ]
                如果filename1可读且可执行，则为真。-o即"或"之意。
        执行过程如下：
				ubuntu@zxw:temp$ cat test3.sh 
				#!/bin/bash
				if [ -r test1.sh -a -x test2.sh ]; then
				    echo "且True"
				else
				    echo "且False"
				fi
				
				if [ -r test1.sh -o -x test2.sh ]; then
				    echo "或True"
				else
				    echo "或False"
				fi
				
				ubuntu@zxw:temp$ ls
				test1.sh  test2.sh  test3.sh
				ubuntu@zxw:temp$ ./test3.sh 
				且False
				或True
    8,  命令1 && 命令2
        &&称为逻辑的AND，其运作方式是：如果"命令1"执行结果为真，才会执行"命令2";
        如果两个皆为真，则传回真值0，否则传回假值1
        代码见：code027_命令1AND命令2.sh
        &&的特性，经常拿来当做是一种隐形的if语法。例如：
            [ -z "$PS1" ] && return
            这行程序代码的意思是：先判断$PS变量值是否为空，如果是，就执行return命令，
            由子Shell环境返回到父Shell，这等于是结束执行该Script。如果用if语法可改写如下：
            if [ -z "$PS1" ]; then
                return
            fi
        再看一例：
            [ -f /proc/net/if_inet6 ] && echo "这部主机支持IPv6"
            判断/proc/net/if_inet6是否存在，如果存在，就显示主机的核心有支持IPv6协议。
            凡是"[ 判断式 ]　&& 指令"的形式，就视为一种隐形的if-then语法。
    9,  命令1 || 命令2
        ||称为逻辑的OR，其运作方式是：如果"命令1"执行结果为假，才会执行"命令2";
        如果两个之中有一个为真，则传回真值0，否则传回真值1。
        同样，||的特性，也可以当做是一种隐形的if语法。例如：
            prefix="/home"
            defpath="/usr/local/bin"
            [ -z ${prefix:-} ] || prefix=${defpath%/*}
            解释：
                1,  行1，设定$prefix的值为/home
                2,  行2，设定$defpath的值为/usr/local/bin
                3,  行3，因$prefix非空，所以，${prefix:-} 变量扩展的传回值为prefix的变量值(非空)，
                    [ -z ${prefix:-} ]对空值的条件测试失败，其结果为假，根据||的
                    特性，接着执行prefix=${defpath%/*}，它会由$defpath后方删去
                    符合/*的最短字符串，即删去/bin，因此，$prefix的值为/usr/local
            本例可改写成if语法如下：
                prefix="/home"
                defpath="/usr/local/bin"
                if [ ! -z ${prefix:-} ]; then
                    prefix=${defpath%/*}
                fi
    10, &&和||合用
        &&和||合用，可以有if-then-else的效果，例如：
            [ -n ${DEBUG:-} ] && set -v || set +v
            这行程序代码，使用-n测试变量DEBUG是否有设非空值，如果有，表示要进行排错，
            接着执行逻辑AND的下一条指令：set -v；如果无，则不进行排错，而执行
            逻辑OR的下一个指令：set +v，他会把显示程序代码的功能关闭。
            这行程序代码，可以改写成：
                if [ -n "$DEBUG" ]; then
                    set -v
                else
                    set +v
                fi
            以后凡是 "[ 判断式 ] && 指令1 || 指令2"的形式，就视为一种隐形的
                if-then-else的语法。
    11, 注意：
            上述这些条件测试中，[[]]和test，[]的意思和用法是相近的，
            但[[]]比test和[]更自由一点，因为[[]]不必担心某些Bash特殊字符对运算符的影响，
            不必写一堆转义字符。如[[ str<xyz ]]是正确的语法，但在[]中却要写成
            [ str \< xyz ] ，这种陷阱很容易忘记。
            在[[]]中，< > && ||等都可以自由地使用，不必使用转义字符。
        除了[[]]之外，在Bash中，(())也不必理上述提到的特殊字符的影响。
        
        在[[ 判断式 ]]中，如果使用==和!=，且在这两个运算符右边的字符串没有加上单引号
        或双引号，则==和!=会视为想要对比该字符串所形成的"样式",如果相符，则传回0，如果不符，传回1
        代码见：code028_在\[\[\]\]判断式中双等号和不等号.sh
                和 code029_if_加上转义.sh
    12, 自Bash 3.2开始，支持在[[]]中运用新的对比运算符=~。
        =~的右边放置想要的对比样式，
        注意：在=~右方的样式，请勿使用引号含括，否则对比功能无法作用。
    
note29: 条件判断式的真假值
    之前提过，在Bash中什么是真什么是假，是以命令的结束状态是否为0来做判断。
    传回0，即为真；传回非0，即为假。
    在Bash中，这种可以影响程序流程的式子，称为条件判断式。
    判断式的操作数，分为"单元"和"二元"两种。
    “-f 文件名” --- 测试文件是否存在。。。。。单元
    "参数1 -gt 参数2" ---　测试参数1的值是否大于参数2。。。。双元 

note30: 关于文件属性的判断式。
   判断式       在什么情况下为真
    -a 文件     如果文件存在 
    -b 文件     如果文件存在，且该文件是区域设备文件
    -c 文件     如果文件存在，且该文件是字符设备文件
    -d 文件     如果文件存在，且该文件是目录
    -e 文件     如果文件存在 
    -f 文件     如果文件存在，且该文件是一般文件
    -g 文件     如果文件存在，且该文件设立了set group id属性
    -h 文件     如果文件存在，且该文件是符号链接文件
    -k 文件     如果文件存在，且该文件设立了sticky位的属性
    -p 文件     如果文件存在，且该文件是管道文件(FIFO)
    -r 文件     如果文件存在，且该文件具可读取的属性
    -s 文件     如果文件存在，且该文件的文件大小大于0
    -t 文件描述符   如果文件描述符是开启的，且链接了某一个终端
    -u 文件     如果文件存在，且该文件设立了set user id属性
    -w 文件     如果文件存在，且该文件有可写入的属性
    -x 文件     如果文件存在，且该文件有可执行的属性
    -O 文件     如果文件存在，且该文件为有效的使用者 id 所拥有
    -G 文件     如果文件存在，且该文件为有效的群组 id 所拥有
    -L 文件     如果文件存在，且该文件是符号链接文件
    -S 文件     如果文件存在，且该文件是Socket文件
    -N 文件     如果文件存在，且该文件自上次读取后，曾修改过
    文件1 -nt 文件2     如果文件1比文件2新，或文件1存在，文件2不存在
    文件1 -ot 文件2     如果文件1比文件2旧，或文件1不存在，文件2存在
    文件1 -ef 文件2     如果文件1和文件2参考到相同的设备和inode编号

note31: 字符串的条件判断式
    判断式              在什么情况下，为真
    -z 字符串           如果字符串长度为0：空字符串
    -n 字符串           如果字符串长度不为0；非空字符串
    字符串              如果字符串长度不为0：非空字符串
    字符串1 == 字符串2  和　字符串1 = 字符串2　在判断式中一样
    "$name"避免为空，报错
    X"$name"提高可移植性

note32: 算式的条件判断式
    要求：  计算结果是数值(如整数)，非字符串
    判断式              在什么情况下为真
    参数1 -eq 参数2     参数1和参数2的值相等
    参数1 -ne 参数2     参数1和参数2的值不相等
    参数1 -lt 参数2     参数1的值小于参数2的值
    参数1 -le 参数2     参数1的值小于或等于参数2的值
    参数1 -gt 参数2     参数1的值大于参数2的值
    参数1 -ge 参数2     参数1的值大于或等于参数2的值

note33: Bash选项的条件判断式
    判断式              在什么情况下，为真
    -o set的选项名称    如果该选项是开启的状态
    见代码：    code036_checkopts_set_o.sh

note34: case条件判断
    语法：  
            case 待测项 in
                样式串1) 命令区1;;
                (样式串2) 命令区2;;
                (样式串3 | 样式串4) 命令区2;;
                ......
                *) 命令区n;;
            esac
    注意：  样式串1)和(样式串1)都行，推荐前者
            区分大小写
            最后*)用来捕捉所有
    自Bash 3.1版开始，引入新选项nocasematch，可让Bash在对比样式时忽略大小写。
        shopt -s nocasematch

note35: 高级样式
    基本样式：
            1， 字符串  如Jack
            2,  通配符  如*表示任意长的字符串
                        如???表示4个字符的字符串
            3,  字符集合    如[p-r]im表示pim，qim，rim
            4,  项目分隔符  |　　只要比对中一项就行
    高级样式：
            Bash的extglob需要打开
            shopt -s extglob
            1,  ?(样式串)： 如果符合0个或1个括号里面的样式，就符合
            2,  *(样式串)： 如果符合0个以上括号里面的样式，就符合
            3,  +(样式串)： 如果符合1个以上括号里面的样式，就符合
            4,  @(样式串)： 如果符合括号里面样式串的其中一个，就符合
            5,  !(样式串):  只要不是出现在括号里面的样式串，就符合

note36: for的语法
    1,  串行
                for 变量 in 串行
                do
                    命令区域
                done
            (串行是一些字符串的组合，彼此用$IFS所定义的分隔字符隔开)
            (串行：1 2 3 4)
    2,  S@
                for 变量 in $@
                do
                    命令区域
                done
            (IFS=':')
            (PL="root:x:0:ubuntu")
            (for f in $PL)
    3,  类C
                for ((初始条件;终止条件;异动项))
                do
                    命令区域
                done
    4,  无穷循环
                for ((;1;))
                do
                    命令区域
                done

note37: while循环
    1,  语法：
                while 条件测试
                do
                    命令区域
                done
    2,  while循环的经典用法是搭配转向输入，读取文件
        用例；
                #!/bin/bash
                while read line
                do
                    echo $line
                done < ~/temp/cvsfile.txt
    3,  while无穷循环
        while ((1))
        while [1]
        while true
        while :

note38: until循环
    一句话，while是成立循环，until是不成立循环
    until无穷循环
        until ((0))
        until false

note39: select命令
    语法结构和for一样
    语法：
            select 选项变量 in 串行
            do
                命令区域
            done

note40: break和continue
    语法：break n（n一定要大于1）
            一次挑出n个循环
    语法：continue n （n一定要大于1）
            continue 2表示从里面往外跳出2层循环，然后由那一层循环重新开始。
    思考：(这里就是两种的对比
            两层for循环，   如果break 2，直接退出
                            如果contine 2，还会往下执行

note41: 函数的语法
    1， 函数的语法1：
            function 函数名称() {
                命令区域
            }
            (函数名称与小括号之间，可以直接相连，也可以用空格符隔开)
    2,  函数的语法2：
            函数名称() {
                命令区域
            }
    3,  函数的语法3：
            函数名称 {
                命令区域
            }
            (在上面3种写法中，推荐2)
    4,  函数的调用1：
            函数名称
    5,  函数的调用2：
            函数名称 参数1 参数2 参数3
    6,  在函数中，local用来设定变量i是getline函数中专有变量，不会影响Script其他地方也叫i的变量。
    7,  在执行函数期间，Bash会建立一个特别的变量FUNCNAME，该变量值的内容为函数的名称。
        函数定义之后，如果需要，也可以取消函数的定义：
            unset -f 函数名称
    8,  函数的结束状态
            如果直接是return，那么使用echo $?，输出的是0
            如果使用return 3，那么使用echo $?，输出的是3
            好像，如果没有return，函数执行完成之后，也是0

note42: 函数与变量的作用范围
    1， 函数的作用范围
        函数仅在定义的Shell环境中有效，Bash执行函数时，并不会另外再开启一个子Shell。
        如果要传递给子Shell环境使用，可使用内置命令export和-f选项，语法如下：
            export -f 函数名称
            举例：  export -f getline
        这样，getline就变成环境变量的一部分(以函数型存在)，可供子Shell的Script使用。
    2,  变量的作用范围
        在函数中，一般使用local进行限制。

note43: 位置参数：
    1,  传递参数
        使用全局变量，很容易被修改
        推荐使用位置参数
    2,  位置参数
        $0：Script文件名
        $1：第一个位置参数
        $2：第二个位置参数
        ${10}：第10个位置参数
        $#：代表参数的个数
        $@：代表所有以空白隔开的参数
        $*：所有参数所组成的字符串
        传递给函数的语法：
            函数名称 参数1 参数2 参数3
    3,  把参数拿来当做特殊的命令使用
        具体代码见：code056_函数_appendfile.sh

note44: 移动位置参数
    Bash的内置命令shift可以往前移动位置参数的值。
    语法：
            shift n
    语法：
            shift
            等同于
            shift 1 

note45: 指定位置参数值
    有时候，为了特殊目的，会故意指定位置参数的值，称为重置(reset)
    Bash的内置命令set，可以达到这项目的。
    代码见：
            code059_setpairs_reset.sh
            code060_setpairs2_reset.sh
    如果要一次重置所有的位置参数，使其值为空，可执行：set --
    在程序中，运用位置参数传递参数值给函数时，原有的位置参数会被保存。
    其内含值并不会受到影响。
    代码见： code061_setpairs3_reset.sh

note46: 取用命令行的选项和参数
    选项：  -
    参数：  不带-
    用这个例子：./opt.sh -u Jack -a -h
    选项和参数的次序并没有统一的规定。
    getopts获得选项和参数：
        语法：  getopts 选项行 选项变量
        选项行：    可以使用u:ah
                    u后面带:表示：该选项需要提供一个参数
                    
                    如果u后面，没有接上一个参数，那么会出现
                    "option requires an argument -- u"的错误信息。

                    如果不想出现这样的错误信息，那么可以在选项行前面加上:
                    如：:u:ah
                    (这样就不会出现错误信息)

        选项变量：  
                    getopts由命令行取得选项，把它放入选项变量中。
                    如果该选项需要额外的参数，参数值会放入OPTARG这个变量中
                    (对于例子中，OPTARG就是Jack)
    代码见：code062_opt_getopts.sh

note47: 建立函数库
    函数名的第一个字符使用_
    代码见：    code063_mylib1.sh
                code064_getip2.sh

note48: 递归函数
    代码见：code065_factor_递归_求阶乘.sh

note49: 函数实例
    抽奖程序
    目标：
        1， 用户指定要产生多少组抽奖号码，最多99组
        2， 每个号码介于1~42，一组有6个号码，但不能重复
    代码见：
        S005_LinuxShell编程与服务器管理/code066_loto_抽奖程序.sh

note50: 转向---文件代码
    所谓文件代码，是指操作系统赋予已开启文件的一个编号(由0开始)，
    作为追踪文件之用，如对这个文件进行读取或写入的操作，都使用文件代码来做沟通。
    操作系统默认指定3个文件代码：0给标准输入(stdin)、1给标准输出(stdout)，
    2给标准错误(stderr)，这三个文件在建立Shell环境时，已开启，往后，如果开启
    新文件，则分配3以上的号码。

    <转向输入，省略文件代码，默认0
    >转向输入，省略文件代码，默认1
    
note51: 转向---操作文件
    这里的"操作文件"是指：运用转向的概念，开启文件、复制文件和关闭文件。
    1,  开启文件
        语法：
                fd<>文件
                (用这种方式开启的文件，可供读写)
                (fd是指定的文件代码)
        用例：
                exec 6<>test.txt
                (使用exec执行转向，开启文件test.txt，并指定其文件代码为6)

    2,  关闭文件
        语法：
                fd<&-
                (关闭转向输入文件)
                (fd是指定的文件代码)
        用例：
                exec 6<&-
                (关闭文件代码6)
         
        语法：
                fd>&-
                (关闭转向输出文件)
                (fd是指定的文件代码)
        用例：
                exec 5>&-
                (关闭文件代码5)

note52: 转向---复制文件，建立文件链接
    1,  复制转向输入的文件代码m，存成文件代码n，使n链接到m
        n<&m
    2,  复制转向输出的文件代码m，存成文件代码n，使n链接到m
        n>&m
    
        用例1：
                exec >&6
        用途1：
                同于 exec 1>&6
                将标准输出链接到文件代码6，因此，凡是原本出现在标准输出的内容
                会转存至文件代码6

        用例2:
                cat <&6
        用途2:
                同于 cat 0<&6
                将文件代码6的内容，转向至标准输入，而由cat把内容显示出来。

        用例3：
                exec 5<&0
        用途3：
                复制标准输入(0)，存成文件代码5，即建立文件代码0的链接。
                简单来说，就是标准输入的备份。

        用例4：
                一旦备份好标准输入后，就可以对标准输入进行操作，
                如转向输入。操作完毕，接下来应该还原标准输入，方法如下：
                    exec 0<&5 5<&-
        用途4：
                这里也可以分成两行来写：
                    exec 0<&5
                    exec 5<&-
                将存储在文件代码5的标准输入还原，并关闭文件代码5。
                这样，原标准输入的功能不会受到影响。

note53: 转向的用法：
        1,  转向输入
                语法：
                        fd<文件
        2, 转向输出
                语法：
                        fd>文件
                注意：
                        如果文件不存在，会建立一个新文件。
                        如果文件存在，则该文件的内容会被清空。
                修改：
                        如果不想文件被清空，以下指令关闭覆盖文件的默认操作：
                            set -o noclobber
                        使用以下指令，效果一样。
                            set -C

                用例：
                        >左方省略fd；fd默认为1，指的就是标准输入转向。
                        常见运用有以下：
                        A， 制造空文件：
                             > test.txt
                             开启空文件test.txt
                             以下做法，效果同上：
                             : > test.txt
                             :为Bash的空命令，什么也不做。转向输出的效果：
                                                产生空文件test.txt
                        B， 存储命令执行的输出：
                             ls > dirs.txt
                             将ls的输出转向存储在文件dirs.txt。这个方法在
                             写脚本时，经常使用。
                       
                        C， >左方文件代码不空
                             exec 6> out.txt
                             echo "hello world" 1>&6
                             行1，开启文件out.txt作为输出，文件代码6
                             行2，将echo原本会显示在标准输出的信息，存储在代码6

        3,  转向输出
                语法：
                        fd>|文件
                用途：
                        和>相同，但是>|不会理会noclobber选项，只要"文件存在"，
                        就会强制覆盖，清空该文件内容。
                用例：
                        ls >| dirs.txt
                        不管noclobber选项是否开启，只要dirs.txt存在，该文件内容一定会被清空。
                >和>|的比较如下：
					ubuntu@zxw:~$ ls > dirs.txt
					ubuntu@zxw:~$ cat dirs.txt
					dirs.txt
					github
					temp
					ubuntu@zxw:~$ set -o noclobber
					ubuntu@zxw:~$ ls > dirs.txt
					-bash: dirs.txt: cannot overwrite existing file
					ubuntu@zxw:~$ ls >| dirs.txt

        4,  转向附加
                语法：
                        fd>>文件
                用例：
                        ls >> dirs.txt
                        写在文件后面

        5,  标准错误伴随标准输出做转向
                语法：
                        &>文件
                    或
                        >&文件
                用例：
                        ntpdate time.stdtime.gov.cn &> /dev/null

                    解释：
                    1， 使用ntpdate向ntp主机校时，如果执行时产生错误，
                        则伴随执行过程产生的信息，转向输出至/dev/null。
                    2， 由于null文件的特性，所有信息均无声无息地消失。
                    3， 这道指令的编写者，不希望校时的过程产生任何信息，
                        以免避免破坏执行画面，或者，运用在crontab时，
                        不想在系统日志文件中留下信息，以避免日志文件原来越大。

        6， &>的作用，其实和以下的写法的作用是相同的。
                >文件2>&1
            上面这条的意思是：转向输出至"文件"，标准错误代码2链接至标准输出1，
            其效用和 &>相同。因此，上述范例可改写成：
                ntpdate time.stdtime.gov.cn >/dev/null 2>&1
       
note54: Here Document转向
    之前介绍的是：可以把标记之间的内容利用转向输出的方式交给指定的命令去处理之外。
    现在有：可以供应给开启的文件读取，语法如下：

        fd<<标记
        资料
        ......  
        ......  
        ......  
        标记

    范例：
        
        #!/bin/bash

        exec 6<<EOF
        line1
        line2
        line3
        EOF

        while read <<&6
        do
            echo $REPLY
        done

    执行过程如下：

			./code069_HereDocument.sh 
			line1
			line2
			line3

note55: trap---陷阱
    1,  在Script的执行过程中，有时候希望能够实时处理系统传来的信号，
        如用户按下了Ctrl+c。
    2， 处理的方式可分为两种：接受信号或忽略信号。
        接受信号：通常会对信号安排执行特定的命令。
        忽略信号：主要是向避免意外的状况干扰Script的运行。
    3， 像这种能捕捉特定信息，并做出反应的机制，称为trap(陷阱触发)

note56: trap---信号(singal)---进程编号PID
    1,  为了方便通信，每个进程都有一个独一无二的代码
    2,  代码叫进程编号(Process IDentification)简称PID
    3,  在命令语法中传递信号的对象，就是进程代码。
    4,  使用如下命令可以列出内存中所有的进程：
        ps auxw
        或
        ps -ef
    5,  使用如下指令可以找出特定的进程，如要找sshd
        ps auxw | grep named | grep -v grep
    6,  为了更加方便使用，可以编写Shell来显示进程的PID
        见代码：
            code070_trap_getpid1.sh sshd
    7,  如果主机中没有sshd进程可用，可开启一个终端窗口，执行top命令。
        再开启一个窗口执行code070_trap_getpid1.sh top，这时的进程关键词是top

note57: trap---信号(singal)---信号列表
    1,  系统定义的信号，可用以下指令列出：
        kill -l    (这个是l，不是数字1)
        trap -l    (这个是l，不是数字1)
        输出结果，示例如下：
			trap -l
			 1) SIGHUP   2) SIGINT   3) SIGQUIT  4) SIGILL   5) SIGTRAP
			 6) SIGABRT  7) SIGBUS   8) SIGFPE   9) SIGKILL 10) SIGUSR1
			11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
			16) SIGSTKFLT   17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
			21) SIGTTIN 22) SIGTTOU 23) SIGURG  24) SIGXCPU 25) SIGXFSZ
			26) SIGVTALRM   27) SIGPROF 28) SIGWINCH    29) SIGIO   30) SIGPWR
			31) SIGSYS  34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
			38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
			43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
			48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
			53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
			58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
			63) SIGRTMAX-1  64) SIGRTMAX

    2,  每个信号都有一定特定的数字代码，如 SIGINT定义的代码是2。
        信号名称都是以SIG开头，也可以忽略不写，也就是说SIGINT和INT是相同的。
        信号名称不分大小写皆可。
        在传递信号时，可使用数字代码，也可以使用信号名称。

    3,  要让前述DNS的daemon程序named重新启动，可执行：
            kill -1 11198   (注意，这里是数字1，不是小写字母l)
        或使用信号名称：
            kill -HUP 11198
            kill -SIGHUP 11198

    4,  信号的定义有几个标准，如POSIX.1。如果要查看各个信号的定义，可执行：
        man 7 signal

note57: trap---信号(singal)---传送信号的方法
    1,  使用内置命令kill，可传送信号给进程。
        传送的语法如下：
            kill -信号 进程编号
        或
            kill -s 信号 进程编号
        或
            kill -n 信号 进程编号

        解释：  "-信号"可使用信号代码或信号名称。kill可后接多个进程编号，
                kill会把指定的信号都传送给这些进程。
                如果省略"-信号"，则默认传送SIGTERM(代码15)信号给进程。

    2,  用例：
                kill 2359
            等同于
                kill -TERM 2359，意思是要终止进程2359

    3,  如果要强制终止，应改用：
                kill -9 2359
                或
                kill -KILL 2359

    4,  除了使用kill可传送信号给进程，killall这个命令也可以。
        killall使用的选项和kill相同；
        和kill不同的是，killall传送信号的对象是进程的名称。
        用例：
                当Firefox浏览器因故挂了，可使用以下指令终止firefox：
                killall firefox-bin
                killall -9 firefox-bin

note58: 常用的信号：
    信号名称        信号代码   说明
    HUP             1           重新启动进程
    INT             2           按Ctrl-c键，终端程序
    QUIT            3           按Ctrl-\键，以内核转储的方式离开程序
    TERM            15          终止进程
    KILL            9           强制删除进程
    STOP            19          暂停进程
    CONT            18          继续执行
    TSTP            20          按Ctrl-z键，在终端中暂停进程
    ABRT            6           放弃进程，并转存内核(core dump)信息
    SEGV            11          内存区段错误，并转存核心信息

    TIP:    最好使用信号名称，而非信号代码，这样可移植性更高。

note59: trap的运用
    1,  trap的语法一：
            trap "触发指令" 信号串行
        用途：
            向Shell注册信号，只要系统产生此特定的信号(就是掉到我们安排的陷阱中)，
            trap指令就会触发，并执行trap命令中的"触发指令"。
        用例：
            trap ‘echo "收到ABRT信号..."’　ABRT
            本例，向Shell注册了一个ABRT的信号，只要系统出现ABRT信号，就会执行echo
            指令。
            向目前的Shell发出ABRT信号的方法：
                kill -ABRT $$
            其中，$$代表目前Shell的进程编号。使用$$，就不必用ps指令去找Shell的PID
            执行结果如下：
				ubuntu@zxw:~$ trap "echo '收到ABRT信号'" ABRT
				ubuntu@zxw:~$ kill -ABRT $$
				收到ABRT信号
				
            注意：Bash会对trap指令读取两次，
                    一次是读取trap指令内容时，
                    一次是执行触发指令时。
            因此最好使用单引号含括"触发指令"，以免Bash先对它进行变量替换等动作。
            
    2,  trap的语法二
            trap - 信号串行
        用途：
            如果trap的语法中没有触发指令，而是-或者空白，则可恢复信号串行原本的作用。
        用例：
            trap '-' ABRT
        TIP：
            通常在Script中，如果曾使用trap对某些信号做过其他安排，那么
            在Script结束前都会再用trap命令来恢复这些信号原本的作用。

    3,  trap的语法三
            trap '' 信号串行
        用途：
            忽略系统发出的"信号串行"
            如果"触发信号"的部分是空字符串''，那么，Shell会忽略这些"信号串行"，
            不做任何反应。
            例如，想忽略使用者按下的ctrl-c组合键，可写成
                trap '' INT
            这样无论按下多少次ctrl-c，都无法终端sleep.sh的执行。
        执行过程如下：
				./sleep.sh 
				我还在睡觉
				我还在睡觉
				^C^C我还在睡觉
				^C^C^C^C我还在睡觉
				^C^C^C^C我还在睡觉
				^C^C^C^C^C我还在睡觉
				我还在睡觉
				Killed
    4,  trap的语法四
        语法：
                trap -p
        用途：
                列出目前trap向shell注册的信号列表
        示例如下：
				trap -- '' SIGINT
				trap -- 'echo '\''收到ABRT信号'\''' SIGABRT
				trap -- '' SIGTSTP
				trap -- '' SIGTTIN
				trap -- '' SIGTTOU
				
        执行：trap '-' INT
        再trap -p如下：
				trap -- 'echo '\''收到ABRT信号'\''' SIGABRT
				trap -- '' SIGTSTP
				trap -- '' SIGTTIN
				trap -- '' SIGTTOU

note60: sed和awk入门---正则表达式
    1， \{...\}指定符合的个数
        用途：指定前面的(左邻)字符的个数
        例如：[a-z]\{3,5\}代表小写字母组成的字符串，长度是3~5

    2， \(...\)把比对符合的字符串暂时保存起来
        例如：H\(..\)y表示要保存H和y之间的3个字符。
        若要提取保存的字符串，可用位置参数，\1代表第一个保存的字符串，依次类推。
    

note61: sed和awk入门---sed的用法
    1,  sed是一种非交互式的流编辑器，可动态编辑文件。
    2,  sed语法：
            sed '样式命令' 文件
            解释：  如果文件中某一行符合"样式"，就执行指定的sed命令，
                    如删除(d)，取代(s)。
                    这里的"样式"使用一对//包括，表示寻找之意；
                    也可以指定数据行的范围，例如：1,6表示作用范围是第一行到第六行；
                    /AAA/,/DDD/表示作用范围是从含有AAA的数据行，到含有DDD的数据行。
            注意：
                    1， sed并不会更改文件内容
                    2， sed的工作方式是读取文件内容，经流编辑之后，把结果显示到标准输出。
                    3， 如果想要存储sed的处理结果，得自行运用转向输出将结果存成其他文件。
    3,  sed的用法一：删除某一段范围的数据行
            sed '1,4d' dataf1
            用途：  把第1行到第4行数据删除，剩下的显示出来。d是sed的删除命令。
    4,  sed的用法二：把含有"样式"的数据行删除
            sed '/La/d' dataf2
            用途：  把含有La的行删除，剩下　的显示出来。其中，//代表搜索之意。
            sed '/[0-9]\{3\}/d' dataf3
            用途：  把含有"3位数"的行删除，剩下的显示出来。
            sed '/^$/d' dataf4
            用途：  删除空白行。^表开头，$表尾部，这两者没有任何字符，代表该行是空白行。
    5,  sed的用法三：把不含有"样式"的数据行删除
            sed '/La/!d' dataf5
            用途：  把不含有La的行删除，剩下的显示出来。
                    !是否定，表示不符合样式者。
    6,  sed的用法四：把含有"样式"的数据行显示出来
            sed '/La/p' dataf6
            用途：  p把目前的数据显示出来。
            因为sed默认也会显示不符合的数据行，应改用以下指令：
            sed -n '/La/p' dataf7
            -n会抑制sed显示其他资料行的默认操作，只显示符合样式的数据行。
    7,  sed的用法五：取代
            sed -n 's/La/Oo/p' dataf8
            这里s是取代的意思，第一对//包含的字符串(La)是搜索的目标。
            第二对//包括的是置换的字符串(Oo)。会将数据行中的字符串La换成Oo
            上面只会替换第一个出现的La，如果需要全部替换：
            sed -n 's/La/Ol/gp' dataf9
            用例1： sed -n 's/La//p' dataf0
                    删除，替换成空字符串
            用例2： sed 's/^...//' dataf0
                    把每一行开头的3个字符删除
            用例3： sed 's/...$//' dataf1
                    把每一行末尾的3个字符删除
    8,  sed的语法六：取用符合样式的字符串
            sed -n 's/\(La\)/\1Oo/p' dataf2
            把找到的La存起来，用\1取回来再使用。
            这个指令作用的结果：如果数据行有La字符串，则第一个出现的La会替换成
                                LaOo，然后显示这些含有La的数据行。
    9,  sed的语法七：找到符合样式的数据行后，再进行取代的操作。
            用例1： sed -n '/AAA/s/234/567/p' dataf3
                    找到含有AAA的那一行之后，将234换成567
            用例2： sed -n '/AAA/,/DDD/s/B/567/p' dataf4
                    将含有AAA到含有DDD的那几行，皆将其中的B换成567。
            用例3： sed -n '2,4s/B/567/p' dataf5
                    由第2行到第行，皆将其中的B换成567。

note62: sed和awk入门---awk的用法
    1,  简介：
            awk是一种可以处理数据、产生格式化报表的语言，功能相当强大。
    2,  工作方式：
            读取数据文件，将每一行数据视为一条纪录(record)，每笔纪录以字段分隔符
            分成若干字段，然后输出各个字段的值。
    3,  执行ps auxw的第一条是：
        USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
        root         1  0.0  0.1  33456  1952 ?        Ss   Jun28   0:22 /sbin/init
        像这种固定结构的数据，用awk来处理，特别有威力。
        仅用以下单一指令，可以取得所有进程的PID：
            ps auxw | awk '{print $2}'
    4,  awk常用的作用格式：
        a,  awk "样式" 文件：把符合样式的数据行显示出来
        b,  awk '{操作}' 文件：对每一行都执行{}中的操作
        c,  awk '样式{操作}' 文件：对符合样式的数据行，执行{}中的操作。
    5,  awk的用法一：   awk '/La/' dataf1
                        显示含La的数据行
    6,  awk的用法二：   awk '{ print $1, $2 }' dataf2
                        显示dataf2的每一行的第1和第2个字段
    7,  awk的用法三：   awk '/La/{ print $1, $2 }' dataf3
                        将含有La关键字的数据行的第1及第2个字段显示出来
    8,  awk的用法四：   awk -F: '/^ols3/{ print $3, $4 }' /etc/passwd
                        使用选项-F，指定:为分隔字符，账号ols3的uid(第3字段)
                        及gid(第4字段)显示出来
    9,  awk的用法五：   awk -F: 'BEGIN{OPS="+++"}/^ols3/{ print $1, $2, $3, $4, $5 }' /etc/passwd
                        以:为分隔字符，+++为输出字段分隔符，将账号ols3的第1~5栏显示出来。
                        执行结果：ols3+++x+++1002+++1002+++


note63: sed和awk入门---awk的实际应用
    1,  取得网卡的IP：
            ifconfig | grep 'inet addr:' | grep Bcast | awk '{print $2}' | awk -F: '{print $2}'
    2,  取得网络设备名称：
            cat /proc/net/dev | awk -F: '/eth.:ppp.:|wlan.:/{print $1}'
        采用多选一的样式/ethc.:|ppp.:|wlan.:/。意思是：设备名称可以ech0:、ppp1:、wlan1:这3个其中之一。
        一旦找到符合样式的字符串后，去掉:，取其中的第一个域值，
        因此，可能的答案是eth0或pp1或wlan1
    3,  取得系统内存大小
            cat /proc/meminfo | awk '/MemTotal/{print $2}'
            找到/MemTotal/这一行，再印出第二个字段，得到内存的大小。
    4,  修改CSV文件的各字段的顺序：
            cat dataf0.csv | awk -F, 'BEGIN{OFS=","}{print S2, S1}' > save.txt
            

note64: 进程管理和工作控制---ps
    1,  UNIX  ps -ax 或 ps -a -x
        BSD   ps  ax 或 ps  a  x
    2,  显示目前所有的进程：
        UNIX :
            ps -e
            ps -ef
            ps -eF
            ps -ely
            *** -e表示要选出所有的进程，和-A同义
            *** -f是控制显示格式的选项，表示要列出完整的进程信息
            *** -F也是控制显示格式的选项，表示要比-f列出更多额外的信息
            *** -l和-y均为控制显示格式的选项；-l表示使用长格式，-y表示不要显示旗标。
                这两个选项京城放在一起使用，且-y只能和-l合用。
        BSD :
            ps ax
            ps aux
            ps auxw
            ps auxww
            *** a表示要列出和终端有关的进程，如果和x合用，表示要列出所有的进程。
            *** u是控制显示格式的选项，表示以用户导向的角度来列出进程。
            *** w是控制格式的修饰选项，表示要用较宽的行数来显示进程信息，超过
                宽度的信息会被截掉。如果使用两个w，则不限制显示宽度，信息会全部
                显示出来，不会被截断。
    3, 列出进程的树状结构：
        UNIX :
            ps -ejH
            *** -e表示要选出所有的进程，和-A同义
            *** -j是显示格式的选项，表示要以上工作控制的格式来显示
            *** -H是显示格式的修饰选项，表示要列出进程的层次结构
        BSD :
            ps axjf
            *** a表示要列出和终端有关的进程，如果和x合用，表示要列出所有的进程。
            *** j表示使用BSD风格的工作控制格式
            *** f是控制显示格式的修饰选项，表示要列出进程的阶层结构
    4,  自定义输出字段：
        UNIX :
            ps -eo pid,ni,user,args
        BSD :
            ps axo pid,ni,user,args
    5,  列出某一进程的程序名称和参数：
        UNIX :
            ps -p 1 -o args
        BSD :
            ps p 1 o args
        列出进程编号1的程序名称
    6,  列出某一使用者的进程，或用该用户权利执行的进程：
            ps -U root -u root u
            *** -U，指的是建立进程的使用者名称，称为read user ID(RUID)
            *** -u，指的是进程拥有的权限等同于该使用者，即effective user ID(EUID)
            *** u，最后的那个u是指：以用户导向的格式输出进程信息。

note65: 进程管理和工作控制---进程状态STAT的代码列表
    代码                意义
     D          不可中断的休眠(通常是进行输出输入I/O的进程)   
     R          可执行的(在执行队列的)
     S          等待接受工作(休眠)
     T          被追踪或被终止
     W          分页(只适用于Linux核心2.4以前的版本)
     X          死亡
     Z          僵死(zombie)，所谓zombie是说父进程没有妥善摧毁的子进程
     <          高优先级的工作
     N          低优先级的工作
     L          已分页锁定于内存中
     s          一个session leader
     +          在前台的进程群组中

note66: top命令
    1,  行1top，系统负载：系统现在时间，已经开机时间，目前登录系统的用户数，
                       过去1分钟、5分钟、15分钟等待执行的进程平均数
    2,  行2Tasks，进程统计：进程总数，正在执行的进程数，休眠的进程数，
                            暂停的进程数，僵尸进程数
    3,  行3Cpus，CPU使用率：ur：使用者执行的进程占用CPU的百分比
                            sy：核心系统内部占用CPU的百分比
                            ni: renice的进程占用CPU的百分比
                            id: CPU闲置占用CPU的百分比
                            wa: 等待IO占用CPU的百分比
                            hi: 处理硬件中断占用CPU的百分比
                            si: 处理软件中断占用CPU的百分比
                            st: (书中没有讲)
    4,  行4Mem，显示目前内存使用，buffers：缓冲区大小
    5,  行5Swap，显示目前swap空间使用，cached Mem：快取大小
    6,  行6为空白行
    7,  行7为进程信息的各个字段：
            代号        意义
            PID         进程编号
            USER        拥有进程的使用者
            PR          进程的优先级
            NI          进程的nice值
            VIRT        进程占用的虚拟内存大小
            RES         进程常驻时占用的内存大小
            SHR         可分享给其它进程的内存大小
            S           进程的状态
            %CPU        进程占用CPU的百分比
            %MEM        进程占用的真实内存大小
            TIME+       进程已经占用的CPU时间
            COMMAND     程序名称和参数tomcat7的是java；ubuntu的是root
    8, 操作top的常用命令字符:
        a,  h或?显示操作方法的说明
        b,  离开top的方法；按q结束top，当然，ctrl+c也可以。
        c,  切换信息的显示与否：
            *** 按l(字母)，显示或隐藏top行
            *** 按t，切换显示Tasks和Cpu(s)
            *** 按m，切换显示Mem和Swap行
        d,  切换显示各个Cpu的使用率
        e,  找出某一个使用者的进程：按u键，接着输入使用者的名称。
            如果是u之后，直接按Enter，则列出全部使用者的进程。
        f,  切换显示执行中或闲置中的进程(二选一)，按i键
        g,  切换显示程序(COMMAND栏)的参数，按c键。
        h,  调整更新信息的秒数，默认是3秒更新一次，按d或s键。
        i,  传送信号给某一进程：按k之后，top会询问想要传送信号的进程编号(pid)
            接着询问准备传送的信号，如果直接按Enter键，则默认传送的信号编号为15
        j,  调整进程的优先级：按r键之后，top会询问欲调整的进程编号，接着询问调整的nice值。
        k,  按F或O键，可选择要排序的字段，用法是按F或O键之后，再按域名前的
            字符代码，例如k代表以%CPU字段做排序的依据。
        l,  按R键可切换排序是采用降序还是升序。
        m,  <键可把排序的目标字段往左移一位，按>可把排序的目标字段往右移一位
        n,  按f或o键，往左或右移动欲显示的字段，方法是按了f或o键之后，再按
            域名前的字符代码，按照大写字母表示向左移动，按小写字母表示向右移动。

note67: 传送信号：
    1,  kill命令可以传送信号，如：中断，终止，强制删除进程等操作。
    2,  管理进程的基本原则：先礼后兵。
        先礼：先发送信号给进程，让进程自己完成该做的事情。
        后兵：如果进程不听指挥，或失去控制，再发出强制性的信号。
    3,  以结束一个进程为例：
        a,  如果这个进程不是daemon服务器，就先对它发出HUP的信号，
            如果它不自行结束，就发出TERM的信号，
            再不结束，就发出KILL的信号，强制终止进程。
        b,  如果进程是一个daemon服务器，(如named, vsftpd, apache2等)，
            通常先发出TERM的信号，
            如果无法自行结束，再发出KILL的信号。
    4,  好处是收尾工作：清除缓存盘，锁定文件，进程编号纪录文件等。

note68: 调整进程的优先级：
    1,  进程进入执行Schedule的优先级，称为nice值。
        通常-20~20。nice越小，优先级越高；nice越大，优先级越低。
    2,  只有root，才能调整-20~0的nice值；其他用户一般只能调整0~20的nice值。
    3,  有两个命令和调整nice值相关：nice和renice。
        nice用于尚未执行的程序，renice用于已经执行的程序。
    
note69: nice命令
    1,  语法：      nice -n nice值 程序
        用法：      指定程序执行时的优先级为某一nice值。
                    其中，nice值得范围是-20~19，只有root能运用-20~0
        默认：      如果省略-n，不指定nice值，则预设使用nice值10来执行程序。
    2， 用例1:      nice -n -5 htop
                    指定htop执行的优先级为-5。
    3,  用例2：     nice htop
                    制定htop执行的优先级为10。

note70: renice命令
    1,  语法:       renice nice值 -p PID -g 群组 -u 使用者名称
                    -p,-g,-u3个选项，可单独使用，或组合使用。
        用途：      调整某一个已执行进程的优先级。
    2,  用例1:
                    renice -5 -p 11912
                    假设11912是htop的PID。
    3,  用例2:      
                    renice -5 11912
                    同用例1，但是省略-p
    4,  用例3:      
                    renice +5 -u daemon
                    将所有进程拥有者是daemon的进程的nice值调整为5。
                    若nice值为正，+可以省略不写。
                    执行nice或renice之后，可试用以下指令观察其nice值：
                    ps -p 进程编号 -o ni,args
                    观察的用例：
                        ps -p 11912 -o ni,args

note71: PRI和NI
    PRI=NI+20
    PRI=0~39

note72: 工作控制：
    Bash在互动模式下，允许用户暂停某一进程，稍后再回复执行该进程。
    像这种赋予使用者操控进程的机制，称为工作控制(工作控制)
    操作过程：程序是一个无限循环的程序
        1,  ./code073_jobs_control_sleep2.sh
        2,  ctrl+z暂停进程
        3,  bg将该进程放到后台执行
        (1~3等同于./code073_jobs_control_sleep2.sh &)
        4,  jobs会列出目前的工作
        5,  fg将进程拉回前台
        6,  ctrl+c结束code073_jobs_control_sleep2.sh的执行
    执行过程如下：
		./code073_jobs_control_sleep2.sh 
		程序正在执行中...
		^Z
		[1]+  Stopped                 ./code073_jobs_control_sleep2.sh
		bg
		[1]+ ./code073_jobs_control_sleep2.sh &
		程序正在执行中...
		jo程序正在执行中...
		程序正在执行中...
		bs
		[1]+  Running                 ./code073_jobs_control_sleep2.sh &
		程序正在执行中...
		程序正在执行中...
		fg程序正在执行中...
		
		./code073_jobs_control_sleep2.sh
		程序正在执行中...
    
note73: 工作控制：%控制
    1,  %%和%+可调用现在的工作，使用%-可调用前一个工作：
        流程：
            a,  先用jobs -l显示任务栏表
            b,  使用%-调出前一个工作
            c,  ctrl+c中断
            d,  用jobs -l发现只剩一个工作[2]+一个工作
            e,  %%调用现在的工作
            f,  ctrl+c中断
        执行过程如下：
			ubuntu@zxw:temp$ ./A.sh &
			[1] 2801
			ubuntu@zxw:temp$ ./B.sh &
			[2] 2803
			ubuntu@zxw:temp$ AAAA
			BBBB
			AAAA
			joBBBB
			bs AAAA
			-l
			[1]-  2801 Running                 ./A.sh &
			[2]+  2803 Running                 ./B.sh &
			ubuntu@zxw:temp$ BBBB
			AAAA
			%-
			./A.sh
			BBBB
			^C
			ubuntu@zxw:temp$ BBBB
			jobs -l
			[2]+  2803 Running                 ./B.sh &
			ubuntu@zxw:temp$ BBBB
			%%
			./B.sh
			BBBB
			^C

    2,  %n (n是工作编号)
        等同于 fg %n
        都是将工作编号为n的工作进程到前台执行
    3,  %n & (n是工作编号)
        等同于 bg %n
        都是将工作编号为n的工作进程到后台执行
    4,  %?xxx表示调用程序名称中含有xxx的工作
    5,  %./xxx表示调用程序开头是./xxx的工作
    6,  如果退出shell时，后台还有处于暂停的进程
        再次exit会退出。

note74: 常用的工作控制命令:
    1,  &
        (find / -name "*.txt" > check.log; find / -name "*.conf" >> check.log) &
        这里使用()开启一个子Shell执行find等复合指令，然后用&全放到后台执行
    2,  bg 将暂停的工作放到后台执行
        bg 将现在的工作放到后台
        bg n 或 bg %n 将工作编号n的工作放到后台
        bg %?xxx 将程序名称含有xxx的工作放到后台
    3,  fg将暂停的工作，拉回前台工作
    4,  jobs列出工作
    5,  disown移除工作 
    6,  kill 传送信号给进程或工作
        这里后接的不再是PID，而是工作编号
    7,  wait 等待子进程结束，传回最后一个命令的执行状态
    8,  suspend 暂停目前的Shell
        用法一：暂停一个非login的Shell：suspend
        用法二：暂停目前的Shell：suspend -f
        (当暂停的Shell收到CONT的信号时，才会继续执行)

note75: 进程替换
    1,  进程替换：Process Substitution
    2,  进程替换可让我们把标准输出，一次倒给许多进程作为输入；
        或者由多个进程取得其输出，然后倒给某个进程去处理
    3,  命令<(指令行)
        通过设备文件/dev/fd/n或缓存文件，把进程的输出倒给<左方的命令来读取。
    4,  >(指令行)
        通过设备文件/dev/fd/n或换存盘，把数据提供给()中的进程去读取。
    5,  用例1：
			echo >(true)
			/dev/fd/63
			echo <(true)
			/dev/fd/63
            (echo是借用/dev/fd/63这个设备文件来做输入输出的中介)
    6,  用例2：一次读取一行数据放入数组中
            read -a arr < <(echo 1 2 3 4 5) 
            echo ${arr[2]} 输出3
            (可以将括号中的echo换成其他命令，非常有效果)
    7,  用例3:
            a="/usr/bin"
            b="/usr/local/bin"
            diff <(ls $a) <(ls $b)
            (比较a和b两个目录内容上的差异)
    8,  用例4:
            tar cvf <(gzip -c > test.tgz) /root/tmp
            1,  tar把/root/tmp目录打包
            2,  写入/dev/fd/n
            3,  ()中的进程由/dev/fd中读取数据，然后交给gzip做压缩
                并转向输出存成test.tgz
            效果和tar cvzf test.tgz /root/tmp一样
