note01: Linux/BSD系统分成3个重要部分；
    *核心(kernel)
    *Shell
    *工具程序
    相对应的关系是：
        核心非常复杂，非常难用
        Shell为核心提供良好的接口

note02: Shell根据表现形式：
    *Text base
    *Graphic base

note03: Linux/BSD的Shell种类非常多，
    可以让人自由地更换(使用chsh指令)
    目前常用的Shell有：
    sh / bash / ksh93 / pdksh / csh / tcsh
    sh : Bourne Shell         BSD/Public Domain
    Bash : Bourne Again Shell    GPL
    Bash兼容sh
    在Linux套件中，常用的是Bash

note04: Bash有两种工作模式：
    互动模式和非互动模式
    互动模式：
        interactive mode
        键盘输入命令，必须等待Shell执行完，
        才能执行下一条命令。
    非互动模式：
        Shell Script mode
        non-interactive mode
        设计Shell Script，把要执行的命令写在
        文件中，交由Bash去读取和执行。
        效率高，也称为自动化模式。

note05: Bash Shell的特性：
    *兼容 Bourne Shell (sh)
    *支持许多选项及变量，可自定义Shell的使用环境
    *支持历史命令(history)
    *命令列修订的能力，可重新取用或修改之前执行过的命令
    *具有job control的能力，可控制前台及后台程序
    *具有程序设计的能力
    *具有：普遍且免费，小(文件小)，快(免编译即可执行)，
           准(正确性高)，稳定(可重复试验)，可组合使用。。。

note06: 编写第一个Bash
    #!/bin/bash
    echo "你好 Bash Shell;" 
    保存为hello.sh
    添加执行权限: chmod +x hello.sh
    ./hello.sh回车之后，就能看到结果

note07: 第一个有用的Bash Shell
    cp /dev/null /var/log/apache2/access.log
    利用特殊文件/dev/null(只写文件)，清空apache2的日志文件(文件大小变成0，但文件仍然存在)
    然后 chomod +x /root/cleanlog.sh
    crontab -u root -e
    接着，在vi中填入：
    0 6 * * * /root/clearlog.sh
    那么每天凌晨6时，就会执行clearlog.sh，自动清理log文件。

note08: 在Linux平台部署Bash Linux的环境
    查看SHELL的支持：echo $SHELL
    一般会有 /bin/Bash或者在Ubuntu中/bin/bash
    ls -la /bin/sh
    一般可以看到 /bin/sh是一个link，链接到 /bin/sh --> Bash
    在Ubuntu 14.04中是 /bin/sh --> dash
    只要在.sh文件中指定 #!/bin/bash就行了。

note09: 自行编译最新版本的Bash
    1,  下载Bash的最新版本：http://ftp.gnu.org/gnu/bash/
    2,  下载到的是一个bash-x.x.x.tar.gz文件
    3,  解压 tar -zxvf bash-x.x.x.tar.gz
    4,  进入目录，执行设定。
        ./configure 会将bash安装到/usr/local目录下
        也可以使用 --prefix知道要安装的路径
        ./configure --prefix=/home/zxwtry
    5,  编译
        make
    6,  测试
        make tests
        先执行看看：
        ./bash
        echo $BASH_VERSION
        接着，离开新编译的bash (即执行exit)，回到原来的环境
    7,  安装(注意root和user用户)
        (user可以之前4使用--prefix进行安装，user安装之后，只能是user使用)
        make install
        或者使用
        su -c "make install"
        (make install默认会把bash的执行文件安装在/usr/local/bin中)
        (如果之前4进行了--prefix指定的话，就在自定义的目录) 

note10: 切换使用新版本的Bash Shell
    对应的命令是：chsh命令(即change Shell的简称)
    chsh会检查/etc/Shells这个文件，只有列在该文件中的Shell程序
    ，才算是合法的Shell，才能供使用者选用。
    编辑/etc/Shells文件，在最后添加/usr/local/bin/bash
    或者 echo '/usr/local/bin/bahs' >> /etc/Shells (注意：>会删除文件之前的东西)
    或者 su -c "echo '/usr/local/bin/bash' >> /etc/Shells"
    使用者自行切换： chsh --> 输入密码 --> 输入 /usr/local/bin/bash 
    root帮忙切换： chsh zxwtry  --> 输入 /usr/local/bin/bash
    
note11: 登录主机：分为本机登录(local login)和远程登录(remote login)        
    区分：使用网络登录的就是远程登录

note12: 本机登录的接口：文本接口和图形接口
    在Linux/BSD系统，默认会开启7个终端界面即：tty1 ~ tty7
    其中，文本接口的主机登录，占用tty1 ~ tty6
          图形接口的主机登录，占用tty7
    如果需要在各终端之间切换，可按Ctrl+Alt+F1 ~~~ Ctrl+Alt+F7
    
note13: 远程登录：ssh和telnet等程序来登录，其中openssh是有加密编码
    ssh -l zxwtry 192.168.1.2
    ssh zxwtry@192.168.1.2
    ssh 192.168.1.2 (等同于 ssh -l root 192.168.1.2)

note14: 注销主机、结束终端程序
    exit 或者 Ctrl + D (先ctrl 后 d)

note15: 不同文件形态的代码，表现如下：
    -   一般文件
    d   目录文件
    l   符号链接文件
    b   磁盘设备文件
    c   字符设备文件
    s   Socket文件
    p   连接文件
    其中：一般文件-：纯文本文件，二进制文件，可执行文件等等
          目录d：包含文件的活页夹
          设备文件；字符文件b、磁盘文件c
          内部进程通信文件：Socket文件s、连接文件p(Pipe/FIFO)
          连接文件也是一种内部进程通信的机制：
            一个进程把数据写入Pipe中
            另一个进程则由Pipe读取数据
            数据采FIFO的次序，成为管道
          特殊文件：符号链接文件。
            符号链接文件称为soft link或symbolic link
          有的文件以.开头，表示是隐藏文件，隐藏文件可以是如上任何一种文件。

note16: file的用法
    file /tc/resolv.conf
        执行的结果是：/etc/resolv.conf:ASCII text
        这表示，resolv.conf是一个纯文件文件，属于一般文件
    file /usr/bin
        执行的结果是：/usr/bin:directory
        这表示，/usr/bin是一个目录
    file /usr/bin/ssh
        执行的结果是：/usr/bin/ssh: ELF 64-bit LSB  shared object, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=2f6aacfa7c26a98a02ce2a846cb03f753be0271d, stripped
        这表示，/usr/bin/ssh是一个二进制文件，具有可执行的特点
    file hello.sh
        执行的结果是：code001_print_hello_Bash.sh: Bourne-Again shell script, UTF-8 Unicode text executable
        这表示，hello.sh是一个Bash Script文件，具有可执行的特点
    file /dev/tty
        执行的结果是：/dev/tty1: character special
        这表示：/dev/tty1 是一个字符设备文件
    file /dev/sda
        执行的结果是：/dev/sda: block special
        这表示：/dev/sda是一个磁盘设备文件
    file /dev/initctl
        执行的结果是：/dev/initctl: fifo(named pipe)
        这表示，/dev/initctl是一个连接文件
    file /var/run/mysqld/mysqld.sock
        执行的结果是：/var/run/mysqld/mysqld.sock: socket
        这表示，/var/run/mysqld/mysqld.sock是一个socket文件
    file /bin/sh
        执行的结果是：/bin/sh:symbolic link to "bash"
        这表示，/bin/sh是一个链接到/bin/bash的符号链接文件
    
note17: 文件权限
    UNIX-like系统，将文件模式，分成3种身份、4种权限
    3种身份是：
        u:  自己(user)，即文件的拥有者
        g:  和自己同一组的人(group)
        o:  其他人(other)
        而a代表所有人   
    每种身份皆有4种可能的权限：
        r:  读取权限
        w:  写入权限
        x:  执行权限
        s:  特殊权限  set user id(s)、set group id(s)及sticky bits(t)，简称sst
    UNIX-like系统用10个字符来表示文件模式，如下所示：   
    文件形态 文件拥有者权限 隶属组权限 其他身份的权限
       -        rwx             rwx     rwx
    r --- 4     w --- 2     x --- 1
    如果某一个文件执行时，执行者可以暂时变成"文件拥有者"的身份，则称为具有特殊权限
        set user id，其权限组rwx则改用rws来表示。这种文件，会在原权限值(假定0755)
        之前加上4000，记为4755
        /usr/bin/chsh文件拥有者的权限记为rws，这表示使用者执行chsh时，可暂时用root
        身份来变更login Shell的种类
    如果一个文件执行时，执行者可以暂时变成"用户组"的身份，则称为拥有特殊权限
        set group id，其权限组r-x改用r-s表示，这种文件会在原文件的权限值 (假定0755)
        之前加上2000，记为2755
    如果某一个目录，其中的文件只有文件拥有者才能删除，则称该目录具有特殊权限
        seticky bit，其权限组记为rwt。这种文件会在原权限值(假定0755)之前加上1000
        记为1755
        某个文件drwxrwxrwt(1777)，表示该文件可被其他用户新建文件，读取文件，执行文件
        但是只有文件的建立者才能删除自己建立的文件。
    需要特别小心目录的权限组，以rwx来说，其中x对目录而言不是执行的意义，而是
        可以进入该目录的权限。例如，/var/www的目录属性如下：
        drwx------ 8 www-data www-data 4096 2016-10-16 22:23 /var/www
        这表示，只有执行身份同于www-data的账号，才能进入/var/www这个目录

note18: 设定权限
    chmod 755 hello.sh 
    chmod +x hello.sh 等同于给3种身份加上可执行权限等同于 chmod a+x hello.sh
    如果只是给文件拥有者自己加上执行权限，应执行
        chmod u+x hello.sh
    只是给组身份加上执行权限，应执行
        chmod g+x hello.sh
    只是给其他人身份加上执行权限，应执行
        chmod o+x hello.sh
    如果将+x更改成-x，则是去掉执行权限的意思。
    比如，去掉"其他人身份"执行权限
        chmod o-x hello.sh

note19: 通配符
    两个常用通配符：*和?，其中*代表任意的字符串，可以是空字符串
                              ?代表一个字符，但不可以为空

note20: 转义字符
    在/root下执行 echo 9 * 9 = 81   的结果是 9 github install temp 9 = 81
    在/root下执行 echo 9 '*' 9 = 81 的结果是 9 * 9 = 81
    在/root下执行 echo '9 * 9 = 81' 的结果是 9 * 9 = 81
    在/root下执行 echo 9 \* 9 = 81  的结果是 9 * 9 = 81
    
    执行 echo this is zxwtry's book     的结果是 bash认为输入没有完成 >
    执行 echo this is zxwtry\'s book    的结果是 this is zxwtry's book 
    执行 echo this is zxwtry'\''s book  的结果是 bash认为输入没有完成 > 
    执行 echo this is zxwtry'\'s book   的结果是 this is zxwtry\s book 
    执行 echo this is zxwtry's book'    的结果是 this is zxwtrys book
    执行 echo "this is zxwtry's book"   的结果是 this is zxwtry's book
    执行 echo 'this is zxwtry"s book'   的结果是 this is zxwtry"s book

note21: 常见的转义字符：
    ' --- \'    " --- \"    * --- \*    ? --- \?    \ --- \\
    ~ --- \~    ` --- \`    ! --- \!    # --- \#    $ --- \$
    & --- \&    ( --- \(    ) --- \)    | --- \|    [ --- \[
    ] --- \]    { --- \{    } --- \}    ; --- \;    < --- \<
    > --- \>    / --- \/

note22: 续行符号：\  将上下输入的两行，视为一行
    echo "line 1 \
          line 1 too"
        输出的结果是：line 1 line 1 too
    经常使用的情形如下：
    ./configure \
        --with-apache=../apache_$ApacheVersion \
        --with-mysql=$MYSQLHOME &&

note23: 字符集合
    [] : 所在范围内的某一个字符，其长度为1
        [abc], [a-z], [A-Z], [a-zA-Z]
    由于-已经用于表示集合范围，如果需要在集合中添加-
        那么必须将-放置在集合的开头或者结尾
        [a-z_-]:代表小写字母、下划线、以及-字符
    !放置在集合前面表示非的意思
        [!abc]:只要不是a不是b不是c就行
        [!a-z]:只要不是小写字母就行
        [\!abc]:只要是a b c或者!就行
        [abc!]:只要是a b c或者!就行
    注意[abc.*]:指的是a b c . *中的其中一个

note24: 括号扩展{}
    {g,gc,s}ftp表示的是gftp, gcftp, sftp
    aabb{,.bak}表示的是aabb或者aabb.bak
    mkdir -p /root/temp/{dir1,dir2,dir3}/{a,b,c}:
        在dir1,dir2,dir3目录下，都建立a,b,c3个子目录
    echo {1,2,3}\*{1,2,3}   输出的是：
        1*1 1*2 1*3 2*1 2*2 2*3 3*1 3*2 3*3
    echo {1,2,3}*{1,2,3}    输出的是：
        1*1 1*2 1*3 2*1 2*2 2*3 3*1 3*2 3*3
    echo {1,2,3} * {1,2,3}  输出的是：
        1 2 3 github install temp 1 2 3
    echo {1,2,3}* {1,2,3}   输出的是：
        1* 2* 3* 1 2 3
    
note25: 系统默认开启的文件
    每一个Shell Script执行时(称为"进程"或"处理程序")，
        系统默认会开启3个标准文件，分别是：
        标准输入(stdin)，标准输出(stdout)，标准错误(stderr)
        键盘             屏幕              屏幕
    系统开启这3个标准文件时，是以文件代码做连接。
        标准输入的文件代码为0
        标准输出的文件代码为1
        标准错误的文件代码为2
        称这3个文件为标准I/O(Input和Output)

note26: 标准输入/输出转向
    把标准输入/输出重新指定到别的文件，称为"转向"
    转向输出：echo zxwtry@zxwtry > a.txt
    转向附加：echo zxwtry@zxwtry >> a.txt
    转向输入：使用统计行数的形式来作demo
        输入wc -l回车
        接着输入line1
                line2
                line3
        再按Ctrl+D结束输入
            wc -l会马上计算行数
        wc -l < input.txt会直接输出input.txt的行数

note27: 转向输入转向输出的合用
    用法：命令或Script < 输入文件 > 输出文件
    用例：sort < unsort.txt < sorted.txt
    利用转向输出做建立编辑
        cat > out.sh
        #!/bin/bash
        echo "你好世界"
        按ctrl+D退出编辑，即有一个out.sh文件

note28: 管道
    管道：一个程序的输出，可以变成另一个程序的输入
    优势：不同的程序可以一起合作，完成一项工作
          发挥"组合的力量"
    用法：基本型：命令1 | 命令2
          cat unsort.txt | sort
          cat unsort.txt | sort > sorted.txt
          cat sorted.txt | lp
          (把sorted.txt通过管道，交给打印机程序lp，打印内容)
          多个管道组合：命令1 | 命令2 |... | 命令n
          grep '".*" 4[0-9][0-9]' access.log | grep -o '".*" 4[0-9][0-9]' |
                sort | uniq -c | sort -n | tee alog.txt
                grep: 从日志文件中，找出含有4xx错误信息的数据行
                grep -o : 取出符合样式的字符串，交给sort排序
                相同的数据行，便会摆在一起
                uniq -c : 把重复的数据行删除，并统计重复的次数
                sort -n : 用数值比较的方式排序
                tee : 交给tee打印出结果，同时tee也把结果存储在alog.txt文件中。

note29: UNIX-like程序的工作哲学：
    把一件工作分成几个部分，各部分交由一个小工具去完成，最后通过管道组合起来。
    小工具的开发原则：努力地把一件工作做到最好。

note30: 前台工作、后台工作
    前台工作：  每执行一条指令，都要等到该指令执行结束后，才能取得键盘的控制权
                然后再执行下一条指令。
    后台工作：  利用操作系统分时的架构，将工作放到后台；在工作未完成之前，
                仍然拥有键盘的控制权。
    ./my-work.sh &
        & 符号表示：把my-work.sh 放到后台执行
    此时，系统会显示该程序的进程编号，例如[1] 11973
    在my-work.sh运行过程中，在Shell中仍然能够执行其他程序。
    当my-work.sh执行结束，系统会显示：
        [1]+ Done    ./my-work.sh

note31: Shell程序的组成
    程序是:code003_shell_structure.sh，运行过程如下：
        ./code003_shell_structure.sh 天竺
        今天是2016-10-17，贫道来自东土大唐，去往天竺拜佛求经
        
        Bye-Bye :-)
    程序结构讲解：
        show_name是一个函数定义如下
            function show_name() {
                echo "今天是$1，贫道来自$2，去往$3拜佛求经"
            }
        三个变量，如下：
			name="$1"
			address="东土大唐"
			today=`date +%F`
        if条件判断语句：
			if [ $# != 1 ]; then
			    echo "Usage: . /$0 {使用者名称}"
			    exit
			fi
        调用show_name函数：
            show_name "$today" "$address" "$name"
        进程睡眠5秒：
            sleep 5
        最后执行一些输出

note32: 执行Bash Scipt的方式：
    方法一：./test.sh
    方法二：bash test.sh
            sh test.sh
    (以上两种方法，Script在执行时，现行的Shell也叫父Shell，
     会开启一个子Shell环境，此Script即是在这个子Shell中执行。
     Script执行完毕之后，此子Shell环境随机关闭，回到现行的Shell中)
    方法三：也可以让Script在现行的Shell中执行，方法如下：
        . /root/temp/test.sh
        source /root/temp/test.sh
        注意.和/之间至少要有一个空格

note33: Bash Script排错的方法
    先检查语法的正确性，然后追踪Script执行的过程，进行排错。
    检查语法的指令如下：(假设将sleep 5 写成 slep 5)
        bash -v code003_shell_structure.sh 天竺
            slep 5
            code003_shell_structure.sh: line 18: slep: command not found 
        只需要修改slep就行了。
    追踪Script的执行：
		bash -x code003_shell_structure.sh 天竺
		+ name=天竺
		+ address=东土大唐
		++ date +%F
		+ today=2016-10-17
		+ '[' 1 '!=' 1 ']'
		+ show_name 2016-10-17 东土大唐 天竺
		+ echo 今天是2016-10-17，贫道来自东土大唐，去往天竺拜佛求经
		今天是2016-10-17，贫道来自东土大唐，去往天竺拜佛求经
		+ sleep 5
		+ echo
		
		+ echo 'Bye-Bye :-)'
		Bye-Bye :-)

note34: 强制变量一定要经过声明才能使用
    bash有一内置命令shopt，可用来设定bash的功能选项。
        其中有一个选项和程序排错有关，如果启用此选项，可避免错打变量名称
        造成程序执行错误的情况。用法如下：
            shopt -s -o nounset

note35: 在特定位置摆放echo指令，可以进行排错。

note36: Bash Script执行的原理：login Shell
    登录主机后，在执行Bash Script之前，所处的环境已经是在一个Bash Shell之中
    这个Shell叫做login Shell，是将来我们执行任何Script的上层环境，又叫做父Shell
    login Shell从何而来：
        每个账号都可以自定义login Shell。
        以Linux来说，账号的login Shell定义在/etc/passwd这个文件里头。
        /etc/passwd的结构：
            /etc/passwd的每一行代表一个账号，共有7个字段，字段之间用:隔开，如下所示：
            账号:x:UID使用者代码:GID群组代码:用户信息:主目录位置:login Shell程序
            第2栏x原为密码栏，基于系统安全考虑，编码后的密码已被放到到/etc/shadow文件之中
            login Shell定义在7个字段。如果在这个字段的Shell程序不存在、不合法(不存在/etc/shells之列)
            或者执行结果失败(如/bin/false)，则这个账号就无法登录主机。
        例如：
			cat /etc/passwd
			root:x:0:0:root:/root:/bin/bash
			daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
			bin:x:2:2:bin:/bin:/usr/sbin/nologin
			sys:x:3:3:sys:/dev:/usr/sbin/nologin
			sync:x:4:65534:sync:/bin:/bin/sync
			games:x:5:60:games:/usr/games:/usr/sbin/nologin
			man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
			lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
			mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
			news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
			uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
			proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
			www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
			backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
			list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
			irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
			gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
			nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
			libuuid:x:100:101::/var/lib/libuuid:
			syslog:x:101:104::/home/syslog:/bin/false
			messagebus:x:102:106::/var/run/dbus:/bin/false
			landscape:x:103:109::/var/lib/landscape:/bin/false
			sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin
			zxwtry:x:1000:1000:zxwtry,,,:/home/zxwtry:/bin/bash
        普通用户可以使用chsh更换login  Shell

note37: 父Shell和子Shell
    当我们执行某一个Shell Script时，父Shell会根据Script程序的第一行#!之后所指定的Shell程序开启
    (此操作称为fork)一个子程序Shell的环境，然后，在子Shell中执行此Shell Script。
    一旦子Shell中的Script执行完毕，此子Shell随机结束，仍然回到父亲Shell之中，不会影响父Shell原本的环境
    子Shell和父Shell一样，会开启3个文件：标准输入，标准输出，标准错误。
        同时，子Shell会继承父Shell的若干变量值的内容，这些变量称为环境变量。 
    执行code004_sub_shell.sh完成之后，不会切换到/root/temp
    如果要切换到/root/temp，可以执行
        . /root/code004_sub_shell.sh
        souce /root/code004_sub_shell.sh
        这样就会切换到/root/temp。
        (这种执行Script的方式，会影响父Shell的环境，通常在做系统调校时，才会如此运用)

note38: 子Shell再开启子Shell
    如何知道目前是在哪一层的Shell呢？
        echo $SHLVL
        也可以使用ps axf，观察内存中各进程之间的层级关系
    echo $SHLVL使用如下：
		root@zxwtry:~# echo $SHLVL
		1
		root@zxwtry:~# bash
		root@zxwtry:~# echo $SHLVL
		2
		root@zxwtry:~# bash
		root@zxwtry:~# echo $SHLVL
		3
    ps axf如下：
          1044 ?        Ss     0:00  \_ sshd: root@pts/1    
		  1184 pts/1    Ss+    0:00  |   \_ -bash
		  1128 ?        Ss     0:00  \_ sshd: root@pts/2    
		  1245 pts/2    Ss+    0:00  |   \_ -bash
		  1136 ?        Ss     0:00  \_ sshd: root@pts/5    
		  1304 pts/5    Ss+    0:00  |   \_ -bash
		  1197 ?        Ss     0:00  \_ sshd: root@pts/6    
		  1364 pts/6    Ss     0:00      \_ -bash
		  2746 pts/6    S      0:00          \_ bash
		  2756 pts/6    S      0:00              \_ bash
		  2766 pts/6    R+     0:00                  \_ ps axf
				
note39: POSIX
    POSIX: Portable Operating System Interface
    POSIX: 可移植操作系统接口
    POSIX: 期望获得源代码级别的软件可移植性。
           (为一个POSIX兼容的操作系统编写的程序，应该可以
            在任何其它的POSIX操作系统上编译执行)

note40: Bash Shell的启动配置文件
    Bash有5种运行模式：
        1,  互动模式
            (Bash的输入、输出都和终端连接)
            (Bash由键盘读取用户输入的指令来执行)
            (须等一个指令执行完了之后，才能执行下一条指令)
            (命令行互动)
        2,  非互动模式
            (执行一个Scrpt程序)
        3,  以sh名称调用
        4,  POSIX模式
        5,  限制功能模式
    在不同的运行模式中，Bash调用不同的启动配置文件。
    Bash的启动配置文件，主要与Shell的环境设定有关。

note41: Bash Shell的启动配置文件---登录(login)，注销(logout)
    登录时候，
    首先，login Shell先执行 /etc/profile
    接着，检查用户的主目录中，是否有 .bash_profile
          .bash_login  .profile三个文件之一
         (优先级：.bash_profile > .bash_login > .profile)
    注销时候，
    bash检查主目录中是否有.bash_logout。如果有，执行它。

note42: Bash Shell的启动配置文件---执行新Shell
    执行新Shell(非login Shell)，可分成两种情况：
    * 执行交互式的Shell：例如，直接执行bash，产生一个子Shell。
    　此时，bash会读取并执行/etc/bash.bashrc，以及主目录中的.bashrc
    * 执行Shell Script(即非交互式的Shell)：例如，执行Script文件test.sh，
    　它会检查BASH_ENV变量的内容，若该变量有定义，则综合性该变量所定义
      的启动活动文件的内容。
    假定BASH_ENV的内容执行bash_env.sh，如下所示：
    　export BASH_ENV="/home/zxwtry/bash_env.sh"
    bash_env.sh文件内容如下：
        #!/bin/bash
        echo "Hi! BASH_ENV is running."
    tesh.sh文件内容如下：
        #!/bin/bash
        echo "running test.sh"
    运行过程如下：
        export BASH_ENV="/home/zxwtry/bash_env.sh"
		./test.sh 
		Hi! BASH_ENV is running.
		running test.sh
    
note43: Bash Shell的启动配置文件---以sh文件名调用bash
    若以sh文件名调用bash，则仿照旧版的sh执行
    (会尽量兼容于POSIX的标准功能)
    (bash特有的功能将会丧失)
    * login Shell调用/bin/sh：账号登录时使用/bin/sh
      (在/etc/passwd中该账号行的第7字段是/bin/sh)
      (bash会读取并执行/etc/profile和主目录的.profile)
    * 执行交互式Shell：例如，执行/bin/sh，产生一个子Shell
      (bash会检查ENV变量的内容，如果有定义，执行对应文件)
    * 执行Shell Script：若Shell Script第一行#!之后，
      调用的Shell程序是/bin/sh，则bash不会执行任何启动配置文件。

note44: Bash Shell的启动配置文件---以BASH--POSIX的方式执行
    此称为POSIX模式，bash使用与POSIX标准兼容的功能。
    (bash会检查ENV变量的那日容，如果有定义，执行对应文件)

note45: Bash Shell的启动配置文件---以Bash -r或者以rbash的名称调用
    rbash其实只是一个指向bash的soft link。
    执行Bash -r或者rbash，称为受限模式。
    (bash的功能受到许多限制，不能使用cd指令，不能设定或取消环境变量等等)
    (只让登录者拥有少数可用的功能，是一种安全性的考虑)
    (bash会读取、执行主目录里的.bashrc配置文件)
    (尽量少用，不要仅以bash -r作为建立安全Shell环境的唯一凭据)

note46: Bash Shell的启动配置文件---总结
    * 登录
        bash先执行/etc/profile，再调用~/.bash_profile
    * 注销
        bash调用~/.bash_logout
    * 执行新Shell
        在图形接口，执行终端程序或手动执行/bin/bash ||
        在编辑程序中调用Shell(如Emacs的Shell mode)
        会先调/etc/bash.bashrc，再调用~/.bashrc
    * 执行Script(使用#!/bin/bash)
        不调用.bash_profile、.bashrc，但会检查BASH_ENV的内容，
        如果非空，则执行它指定的文件。
    * 执行Script(使用#!/bin/sh)
        不调用任何启动文件，没有其他检查环境变量的操作

note47: Bash Shell Script包含的指令有"内置的"和"命令行程序"两种
    内置的：Bash程序本身就有提供这个功能
    命令行程序：Bash外部的车管内需，独立存在于文件系统中的执行文件
                有时称为"工具"程序，简称外部程序
    判断某一个指令是不是内置命令，可以用"type命令"看出来，例如：
        type echo 执行结果是：
            echo is a shell builtin
            (表明，echo是一个内置命令，bulitin---内含)
        type mkdir 执行结果是：
            mkdir is /bin/mkdir
            (表明，mkdir是一个命令行程序，文件路径在/bin/mkdir)

note48: 内置命令
    Bash Shell的内置命令，由于不需要去搜寻路径($PATH)中查找，
        直接就能执行，因此，速度很快。
    常见的内置命令有：
        alias   bg      bind    break   bulitin case    cd
        command compgen complete        continue        decalare
        dirs    disown  echo    enable  eval    exec    exit
        export  fc      fq      for     getopts bash    help
        history if      jobs    kill    let     local   logout
        popd    printf  pushd   pwd     read    readonly
        return  set     shift   shopt   source  suspend test
        time    trap    type    typeset ulimit  umask   unalias
        unset   until   wait    while


note49: 有意思的命令
    echo -n 不想让它自动换行
        执行结果：
            zxwtry@zxwtry:~$ echo -n "aabb"
            aabbzxwtry@zxwtry:~$
    echo -e 可以让字符串中的特殊字符起作用
        执行结果：
            zxwtry@zxwtry:~$ echo -e "aa\nbb"
			aa
			bb
			zxwtry@zxwtry:~$

note50: printf的用法
    %q  将特殊字符用\转义
        执行结果：
        zxwtry@zxwtry:~$ printf "%q" []{}/
        \[\]\{\}/zxwtry@zxwtry:~$
    %e  科学记数法
        执行结果：
        zxwtry@zxwtry:~$ printf "%e\n" 10000
        1.000000e+04
    %g  由Bash选择使用%f或者%e
        执行结果：
        zxwtry@zxwtry:~$ printf "%g\n" 10000
		10000
		zxwtry@zxwtry:~$ printf "%g\n" 10000.00
		10000
		zxwtry@zxwtry:~$ printf "%g\n" 10000.12
		10000.1
		zxwtry@zxwtry:~$ printf "%g\n" 10000.1233
		10000.1
    %i  等同于%d
    %o  显示八进制数
    %x  显示十六进制数，a-f表示
    %X  显示十六进制数，A-F表示
        执行结果：
		zxwtry@zxwtry:~$ printf "%x\n" 1993
		7c9
		zxwtry@zxwtry:~$ printf "%x\n" -1993
		fffffffffffff837
		zxwtry@zxwtry:~$ printf "%X\n" 1993
		7C9
		zxwtry@zxwtry:~$ printf "%X\n" -1993
		FFFFFFFFFFFFF837
	%%  显示%这个符号	

note51: printf的有意思用法：
    printf "%5s\n" 执行如下：
		zxwtry@zxwtry:~$ printf "%5s\n" YES
		  YES
		zxwtry@zxwtry:~$ printf "%5s\n" YESYES
		YESYES
		zxwtry@zxwtry:~$ printf "%5s\n" YESYESYES
		YESYESYES 
		zxwtry@zxwtry:~$ printf "%-5s\n" YESYESYES
		YESYESYES
		zxwtry@zxwtry:~$ printf "%-5s\n" YESYES
		YESYES
		zxwtry@zxwtry:~$ printf "%-5s\n" YES
		YES  
	    (上面这个YES后面有两个空格)	
    printf "%5.1f\n" 30 
        (5表示包括小数点总共几位)
        (1表示小数占几位)
        执行结果：
			zxwtry@zxwtry:~$ printf "%5.1f\n" 99
			 99.0
			zxwtry@zxwtry:~$ printf "%5.1f\n" 99.99
			100.0
			zxwtry@zxwtry:~$ printf "%5.1f\n" 9.99
			 10.0
			zxwtry@zxwtry:~$ printf "%5.1f\n" 9.9
			  9.9
    printf "%s\n" $STR 执行如下：
			zxwtry@zxwtry:~$ echo $BASH_ENV
			/home/zxwtry/bash_env.sh
			zxwtry@zxwtry:~$ printf "%s\n" $BASH_ENV
			/home/zxwtry/bash_env.sh
			zxwtry@zxwtry:~$ printf "%s\n" "$BASH_ENV"
			/home/zxwtry/bash_env.sh 
    printf -v myvar "ABC 123" 执行如下：
			zxwtry@zxwtry:~$ printf -v myvar "ABC 123"
			zxwtry@zxwtry:~$ echo $myvar
			ABC 123
    printf "%b" "ABC\n1\t23" 这里%b是使字符串中的转义字符生效
			zxwtry@zxwtry:~$ printf "%b" "ABC\n1\t23\n"
			ABC
			1   23
    几个没有见过的转义字符：
        \v  垂直TAB
        \b  退一位
        \f  跳页
        \0  后接8进制数字，显示对应ASCII字符
            zxwtry@zxwtry:~$ printf "%b\n" "C:\0134Program Files"
            C:\Program Files
            (\0134即十进制92，即\这个字符)
    可以和管道一起使用
            zxwtry@zxwtry:~$ printf "%s\n" "ABCDEF" | tr '[A-Z]' '[a-z]'
            abcdef

note52: 有意思的内置命令：
    :(冒号)
        什么都不做，传回真值(即传回0)
        : > test.txt
        这里会建立一个空文件test.txt
    .(半角句号)
        在现行的Shell环境中执行Shell程序
        . myfun.sh
        (.和后续的Shell程序之间，至少要用一个空格)
    Source
        在现行的Shell环境中执行Shell程序
        source myfun.sh
    alias
        显示、设定程序别名(alias)
        执行如下：
                zxwtry@zxwtry:~$ alias
				alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
				alias egrep='egrep --color=auto'
				alias fgrep='fgrep --color=auto'
				alias grep='grep --color=auto'
				alias l='ls -CF'
				alias la='ls -A'
				alias ll='ls -alF'
				alias ls='ls --color=auto'
				zxwtry@zxwtry:~$ alias zxw="study"
				zxwtry@zxwtry:~$ alias
				alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
				alias egrep='egrep --color=auto'
				alias fgrep='fgrep --color=auto'
				alias grep='grep --color=auto'
				alias l='ls -CF'
				alias la='ls -A'
				alias ll='ls -alF'
				alias ls='ls --color=auto'
				alias zxw='study'
    unalias 取消程序别名
    unmask  显示或设定：文件、目录建立时，文件权限的屏蔽值
        umask   执行会显示0022
        通常Linux/BSD等系统建立新文件时，默认的权限值是0666;
                               新目录时，默认的权限值是0777;
        使用umask 022
        表示新文件建立时，权限是0666-0022=0644
            新目录建立时，权限是0777-0022=0755
        (有了umask机制，新建文件和目录，会相对安全一点)
        (称umask为文件的安全滤网)

    history 显示过去曾经执行过的Shell指令
    先看执行过程：
			root@zxwtry:document# echo $HISTFILE
			/root/.bash_history
			root@zxwtry:document# echo $HISTFILESIZE
			2000
			root@zxwtry:document# echo $HISTSIZE
			1000 
        上面：HISTFILE      是保存执行过的指令
              HISTFILESIZE  历史指令的最大长度
              HISTSIZE      互动的Shell中，可记住的历史指令数目
                            (一旦Shell结束，会存入HISTFILE)

    fc   列出主机登录之后、最近执行过的指令
    type 判断bash对某一指令如何编译
         type可能会显示一下几种情况：
            type fg: fg is a Shell builtin，表明fg是一个内置命令
            type if: if is a Shell keyword，表明if是bash保留的关键字
            type ll: ll is aliased to `ls -alF'
            type show_name: show_name is a function
                                            (表明show_name是一个Shell函数)
            type tr: tr is /usr/bin/tr，表明tr是一个独立的执行文件
                                            (文件在/usr/bin/tr)
   set  设定Bash Shell的属性
        (不加属性，显示所有的Shell变量和函数的内容) 
        set -o : 列出所有属性的开关状态
        开启某一个Bash Shell的属性：
            set -o emacs
        关闭某一个Bash Shell的属性：
            set +o emacs
            执行如下：
				root@zxwtry:document# set -o | grep emacs
				emacs           on
				root@zxwtry:document# set +o emacs
				root@zxwtry:document# set -o | grep emacs
				emacs           off
				root@zxwtry:document# set -o emacs
				root@zxwtry:document# set -o | grep emacs
				emacs           on
            			
    set -C 或者 set -o noclobber
	    保护已经存在的文件，避免转向输出时，被覆盖掉文件的内容
        执行如下：
            zxwtry@zxw:temp$ set -C
            zxwtry@zxw:temp$ vim a.txt
            zxwtry@zxw:temp$ echo "aa" > a.txt 
            -bash: a.txt: cannot overwrite existing file
        
    set -u
        如果变量i不存在，则显示错误信息
        执行如下：
	        zxwtry@zxw:temp$ export zxw="zxwtry"
			zxwtry@zxw:temp$ echo $zxwtry
			
			zxwtry@zxw:temp$ set -u
			zxwtry@zxw:temp$ echo $zxwtry
			-bash: zxwtry: unbound variable
			zxwtry@zxw:temp$ echo $zxw
			zxwtry

    set -v
        会让Bash在执行Script时，将其所读入的每一进程代码显示出来。
        (通常用于排错)

note53: shopt设定shopt的行为模式
    shopt 或 shopt -p   显示目前各选项的开关状态
    shopt -s 选项       启用选项
    shopt -u 选项       关闭选项
    shopt -o 选项       使用和set -o相同的选项来设置
    shopt -q 选项       不显示开关状态，以回传状态来判断选项是开或关
                        (0：启用    非0：关闭)
    shopt -s checkwinsize
            打开checkwinsize选项，使bash在每一个指令执行后，检查窗口大小，
            必要时更新行和列
    shopt -s exglob progcomp
            打开extglob选项，比较样式时，可使用比较能力较佳的语法。
            打开progcomp选项，启用可程序化的补齐功能。

note54: time    用法：time Script或指令
    在Script或指令执行结束后，显示real、user、cpu 3种耗用时间的统计
    time ps auxw的时间统计，运行结果如下：
        real    0m0.077s
        user    0m0.020s
        sys     0m0.020s
        这里时间的格式是：分秒.千分之一秒
        时间格式可由bash的内置变量TIMEFORMAT来设定。

note55: read    由标准输入读取一行数据
    用变量保存，对应文件：
        #!/bin/bash
        echo "请输入你的名字"
        read name
        echo "你的名字是：" $name
    用变量保存，运行过程：
        ./code005_read.sh 
        请输入你的名字
        zxwtry
        你的名字是： zxwtry
    用默认的变量名，对应文件：
        #!/bin/bash
		echo "请输入你的名字"
		read name
		echo "你的名字是：" $name
		echo "请输入你的爱好"
		read
		echo "你的爱好是：" $REPLY
    用默认的变量名，对应文件：
		./code005_read.sh 
		请输入你的名字
		zxwtry
		你的名字是： zxwtry
		请输入你的爱好
		吃
		你的爱好是： 吃
	read -p的用法：
        read -p "请输入你的名字"	        
        echo "你的名字是："$REPLY
    read -p经常如下：
        read -p "请按ENTER键继续..."
    read 也可以一次读取一行数据放入数组中，用法如下：
        read -a arr < <(echo 123 45 97 101 88) 
        -a的意思是指定 arr为一个数组变量
    从数组中取出数的方法是：
        echo ${arr[2]}
        运行过程如下：
            root@zxwtry:~# read -a arr < <(echo 123 45 97 101 88)
            root@zxwtry:~# echo ${arr[0]}
            123
            root@zxwtry:~# echo ${arr[1]}
            45
            (其中，<(echo 123 45 97 101 88)是一种进程替换的用法)
    read也可以读取文件的资料行，用法如下：
        read LINE < dataf1
        这样会把dataf1的第一行放入变量LINE中。
        如果数据行的各字段之间是用空格符隔开，可用如下方法分别读取各个字段的值。
        read f1 f2 f3 f4 < dataf1
        如果数据行的各字段之间是用：分隔，如/etc/passwd，可用如下方法，分别读取
        各个字段的值：
        IFS=':'
        read f1 f2 f3 f4 f5 f6 f7 < /etc/passwd
        IFS是字段分隔字符变量。
    read在读取数据时，默认会去掉转义字符的意义(即滤掉\)，例如\n会剩下n
        但若要允许输入数据保留\，可使用-r选项
        read -r TEST
        echo $TEST
        运行过程如下：
			root@zxwtry:temp# cat a
			\r\n\t
			root@zxwtry:temp# read -r TEST < a
			root@zxwtry:temp# echo $TEST
			\r\n\t
			root@zxwtry:temp# read TEST < a
			root@zxwtry:temp# echo $TEST
			rnt

note56: exec    执行指定的程序，取代原来的Shell；或使转向操作生效
    exec 程序/命令
        执行结果：执行"程序/命令"，取代目前的Shell。目前的Shell环境随机结束。
    exec 转向操作
        执行结果：使转向操作生效
    exec < datafile
        执行转向操作，凡是由标准输入读取数据的，皆改向datafile读取

note57: eval    读取参数，结合成一个新指令，在进行变量替换后，予以执行。
    listlog="ls -la /var/log/*.log"
    eval $listlog
    (eval $listlog是读取变量内容并执行它。这是一种间接执行指令的技巧)
    HIS="history"
    eval "$HIS < $USER.log"
    (执行时，不同的使用者会产生不同的日志文件，并以用户的账户$USER当作日志文件的主文件名)

note58: 命令行程序：单独存在的文件，执行前，Shell会先在程序的搜寻路径$PATH中去寻找
    常见的命令行程序有：
        cp      data        who     w       ls      cat     wc
        last    mv          mkdir   rmdir   mv      ps      top
        df      du          dd      ln      sort    sed     awk
        ifconfig            dmesg   diff    hostname        dnsdomainname
        chmod               chown   chgrp   cut     grep    find
        kill    more        less    mount   nice    ping    sleep
        su      tar         gzip    xargs   touch   uname   basename
        dirname tr          uniq    mail    which   locate
    
note59: 常用命令行程序的用法：which
   (由搜寻路径(PATH)中，找出某一命令行程序的文件位置) 
    which 命令
        which会由PATH的内容中，找出第一个符合的程序路径
    which -a 命令
        which会由PATH的内容中，找出所有符合的程序路径
note59: 常用命令行程序的用法：locate
    (由文件名数据库中，找出包含有关键词的文件路径)
    locate lsof
    运行如下：
		root@zxwtry:temp# locate lsof
		/usr/bin/lsof
		/usr/share/bash-completion/completions/lsof
		/usr/share/doc/lsof
		/usr/share/doc/lsof/00FAQ.gz
		/usr/share/man/man8/lsof.8.gz
		/var/lib/dpkg/info/lsof.list
		/var/lib/dpkg/info/lsof.md5sums

note59: 常用命令行程序的用法：date
    (显示、设定系统的日期和时间)
    运行date的结果：Wed Oct 19 22:30:41 CST 2016
    运行date MMDDhhmmYY的结果是： 
        (不知道为什么这个执行不出来)
    运行date +'时间格式'     执行结果：控制时间的输出格式
        date +'%d %H %M'将显示现在的“日 时 分”时间
            20 20 17
        date +'%Y-%m-%d %H:%m:%S %Z'
            2016-10-20 20:10:17 CST
    常用的时间格式代码：
        %d: 日(01-31)       %D: 日期(月/日/年)如：10/20/16
        %e: 日(不足二位数的部分，以空白补齐：" 1"~"31")
        %m: 月(01-12)       %Y: 公元年，如2016
        %F: 等同于%Y-%m-%d  %b: 月份的缩写，用locale的语言显示
        %H: 时(24小时制：00-23)
        %I: 时(12小时制：00-12)
        %j: 天(001-366)
        %k: 时(24小时制，不足两位数的部分，以空白补齐：" 1"~"23")。
        %l: 时(12小时制，不足两位数的部分，以空白补齐：" 1"~"12")。
        %M: 分(00-59)       %n: 换行
        %N: 纳秒(nanosecond, 000000000-999999999)。9位
        %r: 12小时制的时间(时分秒)，例如：08:25:39 PM(USA locale)
                                          下午 8时25分39秒(CN locale)
        %R: 24小时制的时间(时分秒)，例如：20:25(USA locale)
                                          20:25(CN locale)
        %S: 秒(00-59)
        %s: 自'00:00:00 1970-01-01 UTC'到目前为止，所经过的秒数
        %t: 水平TAB
        %T: 24小时制的时间(时:分:秒)，例如：20:31:07
        %u: 星期几(1-7，周一为1，周二为2)
        %Z: 时区，例如CST
    date -R 执行的结果是：产生和RFC-2822兼容的时间字符串
        Thu, 20 Oct 2016 20:33:41 +0800

note60: who: 显示现在谁在登录主机
        root@zxwtry:~# who
		root     pts/0        2016-10-20 20:01 (192.168.220.1)
		root     pts/1        2016-10-20 20:01 (192.168.220.1)
		root     pts/3        2016-10-20 20:02 (192.168.220.1)
		root     pts/4        2016-10-20 20:02 (192.168.220.1)        
		
note61: whoami: 显示自己的登录账号

note62: 组合变量和文件内容
        FROM='zxwtry@qq.com'
        echo $FROM | cat - email.lst | sort
        执行过程如下：
            root@zxwtry:temp# cat email.lst 
			zxwfighting@qq.com
			zxweatting@qq.com
			zxwsleeping@qq.com
			root@zxwtry:temp# FROM="zxwtry@qq.com"
			root@zxwtry:temp# echo $FROM | cat - email.lst | sort
			zxweatting@qq.com
			zxwfighting@qq.com
			zxwsleeping@qq.com
			zxwtry@qq.com
        (-代表标准输入)

note63: head输出文件的前面一部分
    head -n 文件：输出文件的前n行，如果不指定-n，默认输出前10行。
        使用：head -100 /var/log/syslog
    head -c n 文件：输出文件的前nbytes的内容。
        若使用的是-c -n，则表示出了前n bytes不输出，其他全部显示出来。
    head -c 10 /var/log/syslog
        输出syslog前10bytes
    FSIZE=5000
    head -c $FSIZE < /dev/zero > sysfile
        利用/dev/zero建立一个文件sysfile，文件大小是5000bytes

note64: tail输出文件的后面一部分
    tail -n 文件：输出文件的后n行，如果不指定-n，默认输出后10行。
    tail -100 /var/log/syslog
    tail -c n 文件：输出文件的后nbytes的内容。

note65: wc计算文件内含的总字数或行数
    wc -l dataf1
        显示dataf1的文件内容共有几行
    wc -c dataf1
        显示dataf1共有多少字符
    wc -w dataf1
        显示dataf1共有多少个单词(word)
    
note66: ln链接文件(使同一个文件可以有多个文件名)
    ln f1 f2
        执行结果：将f2链接到f1(硬链接)，f2的文件内容、文件大小，都和f1一样
    ln -s f1 f3
        执行结果：将f3链接到f1(软链接)，f3是f1的别名，读取f3时，实际访问f1
    ln -sf f1 f3
        执行结果：同上，如果f3存在，则先删除f3，在ln -s f1 f3

note67: rmdir 删除空目录
    
note68: find  在分层目录中寻找文件
    find 路径 样式 操作
    用例1:  find / -name '*.txt'
        说明：  由根目录开始往下寻找所有扩展名是.txt的文件，找到之后，
                全部列出这些文件的路径文件名(default操作)
            find / -name '*.txt' -print
                就是把找到的文件显示出来
            find / -name '*.txt' -print > findtxt.log &
    用例2:  find . -name '*.txt' -exec rm -f {} \;
        说明：  由现在的目录(.)开始往下寻找扩展名是.txt的文件，找到之后，
                执行(-exec)删除文件的命令。
                其中，-f代表强制删除，{}代表找到的文件，
                ;是执行指令(exec)的终止符号，由于是Bash Shell的特殊符号，需转义
                这个指令会将当前目录下的，所有.txt文件都删除
    用例3:  find /etc -cnewer /etc/passwd
        说明：  由/etc目录，寻找文件状态异动时间比/etc/passwd新的文件
    用例4:  find /root -type d -print
        说明：  使用find的选项-type d，指定要由/root目录中寻找文件形态是"目录"的文件
        b : 区块设备文件
        c : 字符设备文件
        d : 目录
        p : 具名管道
        f : 一般文件
        l : 符号链接文件
        s : socket文件
        (和ll看到的有不同)
    用例5:  find . -print
        在现行目录下，找到什么就印出什么。

note69: tar 用途：将文件或目录包成一个文件(也可以反向解开)，并保留目录结构和文件的权限属性。
    用法1：打包
        tar cvzf etc.tgz /etc
        c : 建立tar文件
        v : 详细显示过程
        z : 呼叫gzip压缩tar文件
        f : 指定文件名
        也可以写成 etc.tar.gz
    用法2: 检查
        tar tvzf etc.tgz
        t : 列出打包内容
    用法3: 解包
        tar xvzf etc.tgz
        x : 解包
        z : 呼叫gzip解压
    用法4:  指定解包位置
        tar xvzf etc.tgz -C test2
        -C : 宝石切换到某一目录。
        (这道指令把etc.tgz放入test2目录中解包)
    用法5:  另一种打包方法
        tar cvf - test2 | gzip -9 > save.tgz
        这个方法适用于不支持选项z的tar版本。
        先用cvf把test2目录打包，-代表把打包结果往标准输出丢，
        经由管道交给gzip进行压缩，最后转向存文件成save.tgz。
        起皱功能，-9表示gzip采用最高的压缩比
    用法6:  另一种解包方法
        gzip -9dc save.tgz | tar xvf -
        这个方法适用于不支持选项z的tar版本。
        先用gzip -9dc把save.tgz解压，其中-d表解压之意，
        -c则表示解压至标准输出，接着通过管道，交给tar解包
        其中-表由标准输入读取数据
    用法7:  备份目录A到目录B
        #!/bin/bash
		A="/root/temp/test1"
		B="/root/temp/test2"
		cd $A
		tar cvf - . | tar xvf - -C $B
		
		#先切花难道test1
		#tar cvf - . 打包test2的内容，其中-代表把打包结果往标准输出中丢
		#接着通过管道，由tar xvf -解包，-C把解包内容放入test2目录。
		#达成备份test1的目的
		#必须保证有test1和test2

note70: basename 取得路径名称中最后的文件名部分
    basename /usr/local/bin/sftp
        显示sftp
    利用如下脚本得到相同结果
    #!/bin/bash
    #仿真basename命令
    bn=${1##*/}
    echo $bn

    执行过程：./bashname.sh /usr/local/bin/sftp

note71: dirname 取得路径名称中目录部分
    dirname /usr/local/bin/sftp
        显示/usr/local/bin
    利用如下脚本得到相同结果
    #!/bin/bash
    #仿真dirname命令
    bn=${1%/*}
    echo $bn

    执行过程：./bashname.sh /usr/local/bin/sftp

note72: sort    对文件文件的每一行做排序
    sort dataf4
        执行结果：将datef4作升幂排序(按ASCII的字符排列顺序，做大小比较)
        root@zxwtry:1021# cat dataf4 
		aaaa
		oooo
		zzzz
		root@zxwtry:1021# sort dataf4 
		aaaa
		oooo
		zzzz
    sort -r datef4
        执行结果：将datef4作降序排序(按ASCII的字符排列顺序，做大小比较)
        root@zxwtry:1021# sort -r dataf4 
		zzzz
		oooo
		aaaa
    sort -n dataf4
        执行结果：将datef4作升幂排序(按字符串的数值大小为比较的标准)
    sort -k 2 dataf4
        执行结果：以dataf5中的第2个字段做排序的依据(以字符串的方式比较)
    如果使用-n选项，则可以使用数值大小来比较：
        sort -nk 2 dataf4
        这里n必须写在选项k之前
    sort -n +2 dataf4
        执行结果：跳过前两烂，以dataf3中的第三栏做排序，且以字符串的数值大小
                  为比较的标准
    sort -nr +2 -t: /etc/passwd
        说明：-t:是说改用:为分隔符，+2是说跳过前两栏，以/etc/passwd中的第三栏
              做降序排序，且-n指示sort以字符串的数值大小为比较的标准，-r是降序排列
    sort <data4> sorted
        说明：sort由标准输入取得转向的数据(data4)，经过排序后，把结果转向存入sorted这个文件中。

note73: uniq    对已排序好的文件删除重复行
    uniq dataf3
        注意事项：若重复行未连续摆在一起，则不会有任何作用
    sort dataf3 | uniq
        执行结果：删除dataf3文件中的重复行
    sort dataf3 | uniq -d
        执行结果：挑出重复行
    sort dataf3 | uniq -c
        执行结果：计算每一行重复的次数

note74: cut     对文件的每一行抽出某一部分
    cut -c2 dataf1
        执行结果：抽出dataf1中每一行的第2个字符
    cut -c3-10 dataf1
        执行结果：抽出dataf1中每一行的第3到第10个字符
    cut -c9- dataf1
        执行结果：抽出dataf1中每一行第9个以后的字符
    cut -c1-3,22- dataf1
        执行结果：抽出dataf1中每一行的第1到第3个字符及第22个以后的字符。
    cut -d: -f1 /etc/passwd
        执行结果：抽出 /etc/passwd各行的第一个字段
    说明：-d:指示cut改用:为分隔符，-f1是第一个字段之意
    上述指令，可取出主机中所有的账号名称。
    cut -d: -f3,4 /etc/passwd
        执行结果：抽出/etc/passwd各行的第3及第4个字段

